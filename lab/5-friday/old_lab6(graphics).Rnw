% To compile this:
% rm(list=ls()); library('knitr'); pat_md(); knit('rgraphics.Rnw')

%------------------------------------------------------------
\chapter{High Quality Graphics in R}
\label{Chap:3}\label{Chap:Graphics}
%------------------------------------------------------------
%
```{r initialize, cache = FALSE, echo = FALSE, message = FALSE, error = FALSE, warning = FALSE}
source("../chapter-setup.R"); chaptersetup("rgraphics.Rnw", "3")
```
%
```{r introplot, echo=FALSE, warning = FALSE, fig.width = 4.2, fig.height = 4.2}
library("xkcd")
library("showtext")
library("sysfonts")
library("tibble")

introplotdata = tibble(
  y = c(seq(-8, 1, length=25)^2, rep(1, 5), seq(1, 5,length=25)^2)^2,
  x = seq(1, 55, length.out = length(y)))

dataman = tibble(
  x = 30,
  y = 400,
  scale = 100,
  ratioxy = 0.1,
  angleofspine =  -pi/2 ,
  anglerighthumerus = -pi/6,
  anglelefthumerus  = pi * 7/6,
  anglerightradius = 0,
  angleleftradius = 0,
  angleleftleg  = 19*pi/12,
  anglerightleg = 17*pi/12,
  angleofneck   = 1.4*pi)

mapping = do.call(aes_string, colnames(dataman) %>% (function(x) setNames(as.list(x), x)))

ggplot(introplotdata) + geom_line(aes(x = x, y = y), size = 2) +
   xkcdaxis(c(0, 50), c(0, 1000)) + xlab("Time to make plot in minutes") +
   ylab("Time to understand plot in minutes") + xkcdman(mapping, dataman) +
   theme(axis.title.x = element_text(margin = margin(15, 0, 0, 0)))
```
%
\begin{marginfigure}[-3cm]
\includegraphics[width=\linewidth]{chap3-r_introplot-1}
\caption{An elementary law of visualization.}
\label{rgraphics:fig:introfig}
\end{marginfigure}
%
There are (at least) two types of data visualization. The first enables a scientist to effectively
explore data and make discoveries about the complex processes at work. The other type of
visualization provides informative, clear and visually attractive illustrations of her
results that she can show to others and eventually include in a publication.

Both of these types of visualizations can be made with R. In fact, R offers multiple
graphics systems. This is because R is extensible, and because progress in R graphics has
proceeded largely not by replacing the old functions, but by adding packages.  Each of the
different graphics systems has its advantages and limitations. In this chapter we'll use
two of them. First, we have a cursory look at the base R plotting functions\footnote{They
  live in the \CRANpkg{graphics} package, which ships with every basic R installation.}.
Subsequently we will switch to \CRANpkg{ggplot2}.

\begin{marginfigure}[-3cm]
\includegraphics[width=\linewidth]{Automatisches_Zeichengeraet_ZUSE_Z64_ubt.JPG}
\caption{The ZUSE Plotter Z64 (presented in 1961). Source: \url{https://en.wikipedia.org/wiki/Plotter}.}
\label{rgraphics:plotter}
\end{marginfigure}

Base R graphics were historically first: simple, procedural, canvas-oriented. There are
specialized functions for different types of plots. These are easy to call -- but when you
want to combine them to build up more complex plots, or exchange one for another, this
quickly gets messy to program, or even impossible. The user plots (the word stems back to
some of the first graphics devices -- see Figure~\ref{rgraphics:plotter}) directly onto a
(conceptual) canvas. She explicitly needs to deal with decisions such as how many
inches to allocate to margins, axes labels, titles, legends, subpanels; once something
is ``plotted'' it cannot be easily moved or erased.

There is a more high-level approach: in the \emph{grammar of graphics}, graphics are built
up from modular logical pieces, so that we can easily try different visualization types for our
data in an intuitive and easily deciphered way, like we can switch in and out parts of a
sentence in human language.  There is no concept of a canvas or a plotter, rather, the
user gives \CRANpkg{ggplot2} a high-level description of the plot she wants, in the form
of an R object, and the rendering engine takes a wholistic view on the scene to
lay out the graphics and render them on the output device.

We'll explore \emph{faceting}, for showing more than 2 variables at a time. Sometimes this is
also called lattice\footnote{The first major R package to implement this was
  \CRANpkg{lattice}; nowadays much of such functionality is also provided through
  \CRANpkg{ggplot2}.} graphics, and it allows us to visualise data in up to four or five
dimensions.

%--------------------------------------------------
\section{Goals for this chapter}
%--------------------------------------------------
\begin{itemize}
\item Learn how to rapidly and flexibly explore datasets by visualization.
\item Create beautiful and intuitive plots for scientific presentations and publications.
\item Review the basics of \Rpackage{base} R plotting.
\item Understand the logic behind the \emph{grammar of graphics} concept.
\item Introduce \CRANpkg{ggplot2}'s \Rfunction{ggplot} function.
\item See how to plot 1D, 2D, 3-5D data, and understand faceting.
\item Creating ``along-genome'' plots for molecular biology data (or along other sequences, e.\,g., peptides).
\item Discuss our options of interactive graphics.
\end{itemize}

%--------------------------------------------------
\section{Base R plotting}
%--------------------------------------------------
%
\begin{marginfigure}[-60mm]
\includegraphics[width=\linewidth]{chap3-r_basicplotting1-1}
\caption{Plot of concentration vs.\ density for an ELISA assay of DNase.}
\label{rgraphics:fig:basicplotting1}
\end{marginfigure}
%
The most basic function is \Rfunction{plot}. In the code below, the output of which is
shown in Figure~\ref{rgraphics:fig:basicplotting1}, it is used to plot data from an
enzyme-linked immunosorbent assay (ELISA) assay. The assay was used to quantify the
activity of the enzyme deoxyribonuclease (DNase), which degrades DNA. The data are
assembled in the R object \Robject{DNase}, which conveniently comes with base R.
\Robject{DNase} is a dataframe whose columns are \Robject{Run}, the assay run;
\Robject{conc}, the protein concentration that was used; and \Robject{density}, the
measured optical density.
%
```{r basicplotting1}
head(DNase)
plot(DNase$conc, DNase$density)
```
%
\begin{marginfigure}[-60mm]
\includegraphics[width=\linewidth]{chap3-r_basicplotting2-1}
\caption{Same data as in Figure~\ref{rgraphics:fig:basicplotting1} but with better axis labels and a different plot symbol.}
\label{rgraphics:fig:basicplotting2}
\end{marginfigure}
%
This basic plot can be customized, for example by changing the plot symbol and axis labels
using the parameters \Robject{xlab}, \Robject{ylab} and \Robject{pch} (plot character), as
shown in Figure~\ref{rgraphics:fig:basicplotting2}. Information about the variables is
stored in the object \Robject{DNase}, and we can access it with the \Rfunction{attr}
function.
%
```{r basicplotting2}
plot(DNase$conc, DNase$density,
  ylab = attr(DNase, "labels")$y,
  xlab = paste(attr(DNase, "labels")$x, attr(DNase, "units")$x),
  pch = 3,
  col = "blue")
```
%$
\begin{ques}
  Annotating dataframe columns with ``metadata'' such as longer descriptions, physical
  units, provenance information, etc., seems like a useful feature. Is this way of storing
  such information, as in the \Robject{DNase} object, standardized or common across the R
  ecosystem? Are there other standardized or common ways for doing this?
\end{ques}
\begin{answer}
  Have a look at the \Rclass{DataFrame} class in the Bioconductor package
  \Biocpkg{S4Vectors}. Among other things it is used to annotate the rows and columns of a
  \Rclass{SummarizedExperiment}\footnote{So the meatadata of the \Rclass{DataFrame} that
    itself serves as metadata to the matrix in a \Rclass{SummarizedExperiment} could be
    called metametadata. This recursion can be repeated ad infinitum. Some people dislike
    the ``meta'' prefix since it is more a subjective comment on rather than an objective
    property of a datum.}.
\end{answer}
%
Besides scatterplots, we can also use built-in functions to create
histograms and boxplots (Figure~\ref{rgraphics:fig:basicplotting3}).
%
```{r basicplotting3, fig.width=3, fig.height=3}
hist(DNase$density, breaks=25, main = "")
```
%$
```{r basicplotting4, fig.width=5.6, fig.height=3.5}
boxplot(density ~ Run, data = DNase)
```
%
Boxplots are convenient for showing multiple distributions next to each other in a compact
space, and they are universally preferable to the barplots with error bars sometimes still
seen in biological papers.  We will see more about plotting multiple univariate
distributions in Section~\ref{rgraphics:sec:univar}.
%
\begin{marginfigure}
\includegraphics[width=\linewidth]{chap3-r_basicplotting3-1}\\
\includegraphics[width=\linewidth]{chap3-r_basicplotting4-1}
\caption{Histogram of the density from the ELISA assay, and boxplots of these values
stratified by the assay run. The boxes are ordered along the axis in lexicographical order because
the runs were stored as text strings. We could use R's type conversion functions to achieve numerical ordering.}
\label{rgraphics:fig:basicplotting3}
\end{marginfigure}
%
The base R plotting functions are great for quick interactive exploration of data; but we
run soon into their limitations if we want to create more sophisticated displays.  We
are going to use a visualization framework called the grammar of graphics, implemented in
the package \CRANpkg{ggplot2}, that enables step by step construction of high quality
graphics in a logical and elegant manner. First let us introduce and load an example
dataset.


%--------------------------------------------------
\section{An example dataset}
\label{rgraphics:sec:exampledata}
%--------------------------------------------------
\begin{marginfigure}
\includegraphics[width=\linewidth]{Yusukecells-2}
\caption{Single-section immunofluorescence image of the E3.5 mouse blastocyst stained for Serpinh1,
a marker of primitive endoderm (blue), Gata6 (red) and Nanog (green).} % Scale bar: 10 $\mu$m.
\label{rgraphics:fig:cells}
\end{marginfigure}
%
To properly testdrive the \CRANpkg{ggplot2} functionality, we are going to need a dataset
that is big enough and has some complexity so that it can be sliced and viewed from many
different angles.  We'll use a gene expression microarray dataset that reports the
transcriptomes of around 100 individual cells from mouse embryos at different time points
in early development.  The mammalian embryo starts out as a single cell, the fertilized
egg.  Through synchronized waves of cell divisions, the egg multiplies into a clump of
cells that at first show no discernible differences between them. At some point, though,
cells choose different lineages.  By further and further specification, the different cell
types and tissues arise that are needed for a full organism. The aim of the experiment,
explained by \citet{Ohnishi2014}, was to investigate the gene expression changes
associated with the first symmetry breaking event in the embryo.  We'll further explain
the data as we go. More details can be found in the paper and in the documentation of the
Bioconductor data package \Biocexptpkg{Hiiragi2013}. We first load the package and the
data:
%
```{r loadHiiragi}
library("Hiiragi2013")
data("x")
dim(exprs(x))
```
```{r checkHiiragi, echo=FALSE}
stopifnot(packageDescription("Hiiragi2013")$Version >=  package_version("1.3.2"), # currently in Bioc-Devel
          "sampleGroup" %in% colnames(pData(x)))
stopifnot(is(x, "ExpressionSet"))
```
%$
You can print out a more detailed summary of the \Rclass{ExpressionSet} object \Robject{x}
by just typing \Robject{x} at the R prompt.  The `r ncol(x)` columns of the data matrix
(accessed above through the \Rfunction{exprs} function) correspond to the samples (and
each of these to a single cell), the `r nrow(x)` rows correspond to the genes probed by
the array, an Affymetrix `r annotation(x)` array.  The data were normalized using the RMA
method~\citep{Irizarry:Biostat:2003}.  The raw data are also available in the package (in
the data object \Robject{a}) and at EMBL-EBI's ArrayExpress database under the accession
code E-MTAB-1681.

Let's have a look at what information is available about the samples.\footnote{The
notation \`r {z <- pData(x)[1, "sampleColour"]; stopifnot(substring(z, 1, 1)=="#"); z}`
is a hexadecimal representation of the RGB coordinates
of a color; more on this in Section~\ref{rgraphics:sec:colorspaces}.}
% Note, the \'r ...' expression assumes that the R code evaluates to a string
% that begins with `#`, which unescaped would be a problem for LaTeX
%
```{r xpData}
head(pData(x), n = 2)
```
%
The information provided is a mix of information about the cells (i.e., age, size and
genotype of the embryo from which they were obtained) and technical information (scan
date, raw data file name). By convention, time in the development of the mouse embryo
is measured in days, and reported as, for instance, \texttt{E3.5}.
Moreover, in the paper the authors divided the cells into
`r length(unique(x$sampleGroup))` %$
biological groups (\Robject{sampleGroup}), based on age,
genotype and lineage, and they defined a color scheme to represent these groups
(\Robject{sampleColour}\footnote{This identifier in the dataset uses the British spelling.
  Everywhere else in this chapter, we use the US spelling (color). The \CRANpkg{ggplot2} package
  generally accepts both spellings.}).
Using the \Rfunction{group\_by} and \Rfunction{summarise} functions from the package \CRANpkg{dplyr},
we'll define a little dataframe \Robject{groups} that contains
summary information for each group: the number of cells and the preferred color.
%
```{r groupSize}
library("dplyr")
groups = group_by(pData(x), sampleGroup) %>%
  summarise(n = n() , color = unique(sampleColour))
groups
```
%
The cells in the groups whose name contains
\texttt{FGF4-KO} are from embryos in which the FGF4 gene, an important
regulator of cell differentiation, was knocked out.  Starting from E3.5, the wildtype cells (without
the FGF4 knock-out) undergo the first symmetry breaking event and differentiate into different
cell lineages, called pluripotent epiblast (EPI) and primitive endoderm (PE).

%------------------------------------------------------------
\section{ggplot2}
\label{rgraphics:sec:ggplot}
%------------------------------------------------------------
%
\begin{marginfigure}
\includegraphics[width=\linewidth]{chap3-r_figredobasicplottingwithggplot-1}
\caption{Our first \CRANpkg{ggplot2} figure, similar to the base graphics
Figure~\ref{rgraphics:fig:basicplotting1}.}
\label{rgraphics:fig:figredobasicplottingwithggplot}
\end{marginfigure}
%
\CRANpkg{ggplot2} is a package by Hadley Wickham \citep{ggplot2} that implements the idea of
\eindex{grammar of graphics} -- a concept created by Leland Wilkinson in his eponymous
book~\citep{GrofGrbook}. Comprehensive documentation for the package can
be found \href{http://ggplot2.org}{on its website}.  The online documentation includes
example use cases for each of the graphic types that are introduced in this chapter (and
many more) and is an invaluable resource when creating figures.

Let's start by loading the package and redoing the simple plot of Figure~\ref{rgraphics:fig:basicplotting1}.
%
```{r figredobasicplottingwithggplot, fig.width = 3.5, fig.height = 3}
library("ggplot2")
ggplot(DNase, aes(x = conc, y = density)) + geom_point()
```
%
We just wrote our first ``sentence'' using the grammar of graphics. Let us deconstruct this sentence.
First, we specified the dataframe that contains the data, \Robject{DNase}.
Then we told \Rfunction{ggplot} via the \Robject{aes}\footnote{This stands for \eindex{aesthetic}, a terminology
that will become clearer below.} argument which variables we want on the $x$- and $y$-axes, respectively.
Finally, we stated that we want the plot to use points, by adding the result of calling the function
\Rfunction{geom\_point}.

Now let's turn to the mouse single cell data and plot the number of samples for each of the
`r nrow(groups)` groups using the \Rfunction{ggplot} function. The result is shown
in Figure~\ref{rgraphics:fig:qplot1}.
%
```{r figqplot1, fig.width=5, fig.height=4}
ggplot(data = groups, aes(x = sampleGroup, y = n)) +
  geom_bar(stat = "identity")
```
%
\begin{marginfigure}
\includegraphics[width=\linewidth]{chap3-r_figqplot1-1}
\caption{A barplot, produced with the \Rfunction{ggplot} function from the table of
group sizes in the mouse single cell data.}
\label{rgraphics:fig:qplot1}
\end{marginfigure}
%
With \Rfunction{geom\_bar} we now told \Rfunction{ggplot} that we want each data item
(each row of \Robject{groups}) to be represented by a bar.  Bars are one geometric object
(\eindex{geom}) that \Rfunction{ggplot} knows about. We've already seen another geom in
Figure~\ref{rgraphics:fig:figredobasicplottingwithggplot}: points.  We'll encounter many
other possible geometric objects later.  We used the \Rfunction{aes} to indicate that we
want the groups shown along the $x$-axis and the sizes along the $y$-axis.  Finally, we
provided the argument \Robject{stat = "identity"} (in other words, do nothing) to the
\Rfunction{geom\_bar} function, since otherwise it would try to compute a histogram of the
data (the default value of \Robject{stat} is \Robject{"count"}).  \Robject{stat} is short
for \emph{statistic}, which is what we call any function of data. Besides the identity and
count statistic, there are others, such as smoothing, averaging, binning, or other
operations that reduce the data in some way.
%
```{r checkgeombar, echo = FALSE}
## check an assertion made in the text above
stopifnot(formals(ggplot2::geom_bar)$stat=="count")
```
%
These concepts --data, geometrical objects, statistics-- are some of the ingredients of
the grammar of graphics, just as nouns, verbs and adverbs are ingredients of an English
sentence.
%
\begin{ques}
\item Flip the $x$- and $y$-aesthetics to produce a horizontal barplot.
\end{ques}

The plot in Figure~\ref{rgraphics:fig:qplot1} is not bad, but there are several
potential improvements. We can use color for the bars to help us quickly
see which bar corresponds to which group. This is particularly useful if we use the
same color scheme in several plots. To this end, let's define a named vector
\Robject{groupColor} that contains our desired colors for each possible value of
\Robject{sampleGroup}.\footnote{The information is completely equivalent to that in the
\Robject{sampleGroup} and \Robject{color} columns of the dataframe \Robject{groups},
we're just adapting to the fact that \CRANpkg{ggplot2} expects this information in the
form of a named vector.}
%
```{r groupColor}
groupColor = setNames(groups$color, groups$sampleGroup)
```
%
Another thing that we need to fix is the
readability of the bar labels. Right now they are running into each other --- a common
problem when you have descriptive names.
%
```{r figqplot2, fig.width=5, fig.height=4}
ggplot(groups, aes(x = sampleGroup, y = n, fill = sampleGroup)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = groupColor, name = "Groups") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```
%
\begin{marginfigure}
\includegraphics[width=\linewidth]{chap3-r_figqplot2-1}
\caption{Similar to Figure~\ref{rgraphics:fig:qplot1}, but with colored bars and
better bar labels.\label{rgraphics:fig:qplot2}}
\end{marginfigure}
%
This is now already a longer and more complex sentence. Let us dissect it.
We added an argument, \Robject{fill} to the \Rfunction{aes} function that
states that we want the bars to be colored (filled) based on \Robject{sampleGroup}
(which in this case co-incidentally is also the value of the \Robject{x} argument, but that need not be so).
Furthermore we added a call to the \Rfunction{scale\_fill\_manual} function, which takes as its
input a color map -- i.\,e., the mapping from the
possible values of a variable to the associated colors -- as a named vector. We also gave this color map
a title (note that in more complex plots, there can be several different color maps involved).
Had we omitted the call to \Rfunction{scale\_fill\_manual}, \CRANpkg{ggplot2} would have used its choice of
default colors. We also added a call to \Rfunction{theme} stating that we want the $x$-axis labels
rotated by 90 degrees and right-aligned (\Robject{hjust}; the default would be to center).

%------------------------------------------------------------
\subsection{Data flow}
%------------------------------------------------------------
\CRANpkg{ggplot2} expects your data in a dataframe\footnote{This includes the base R
  \Rclass{data.frame} as well as the \Rclass{tibble} (and synonymous \Rclass{data\_frame})
  classes from the \CRANpkg{tibble} package in the tidyverse.}. If they are in a matrix,
in separate vectors, or other types of objects, you will have to convert them. The
packages \CRANpkg{dplyr} and \CRANpkg{broom}, among others, offer facilities to this end,
we'll discuss this more in Section~\ref{Chap:Design:sec:datarep}, and you'll see examples
of such conversions sprinkled throughout the book.

The result of a call to the \Rfunction{ggplot} is a \Rclass{ggplot} object. Let's recall a
piece of code from above:
%
```{r ggplotobject}
gg = ggplot(DNase, aes(x = conc, y = density)) + geom_point()
```
%
We have now assigned the output of \Rfunction{ggplot} to the object \Robject{gg}, instead
of sending it directly to the console, where it was ``printed'' and produced
Figure~\ref{rgraphics:fig:figredobasicplottingwithggplot}. The situation is completely
analogously to what you are used to from working with the R console: when you enter an
expression like \Robject{1+1} and hit ``Enter'', the result is printed. When the
expression is an assignment, such as \Robject{s = 1+1}, the side effect takes place (the
name \Robject{"s"} is bound to an object in memory that represents the value of
\Robject{1+1}), but nothing is printed. Similarly, when an expression is evaluated as part
of a script called with \Rfunction{source}, it is not printed. Thus, the above code also
does not create any graphic output, since no \Rfunction{print} method is invoked. To print
the \Robject{gg}, type its name (in an interactive session) or call \Rfunction{print} on
it:
%
```{r ggpprintobject}
gg
print(gg)
```
%
%------------------------------------------------------------
\subsection{Saving figures}
%------------------------------------------------------------
\CRANpkg{ggplot2} has a built-in plot saving function called
\Rfunction{ggsave}:
%
```{r plotsave1}
ggsave("DNAse-histogram-demo.pdf", plot = gg)
```
```{r plotsave2, echo = FALSE, results = "hide"}
file.remove("DNAse-histogram-demo.pdf")
```
%
There are two major ways of storing plots: vector graphics and raster (pixel) graphics. In
vector graphics, the plot is stored as a series of geometrical primitives such as points,
lines, curves, shapes and typographic characters. The prefered format in R for saving
plots into a vector graphics format is PDF. In raster graphics, the plot is stored in a
dot matrix data structure. The main limitation of raster formats is their limited
resolution, which depends on the number of pixels available. In R, the most commonly used
device for raster graphics output is \Rfunction{png}.  Generally, it's preferable to save
your graphics in a vector graphics format, since it is always possible later to convert a
vector graphics file into a raster format of any desired resolution, while the reverse is
fundamentally limited by the resolution of the original file. And you don't want the
figures in your talks or papers look poor because of pixelization artefacts!

%--------------------------------------------------
\section{The grammar of graphics}
%--------------------------------------------------
\begin{marginfigure}
\includegraphics[width=\linewidth]{chap3-r_figscp2layers1-1}
\caption{A scatterplot with three layers that show different statistics of the same data:
points, a smooth regression line, and a confidence band.}
\label{rgraphics:fig:scp2layers1}
\end{marginfigure}

The components of \CRANpkg{ggplot2}'s grammar of graphics are
\begin{enumerate}
\item one or more datasets,
\item one or more geometric objects that serve as the visual representations of the data,
  -- for instance, points, lines, rectangles, contours,
\item descriptions of how the variables in the data are mapped to visual properties
  (aesthetics) of the geometric objects, and an associated scale (e. g., linear,
  logarithmic, rank),
\item one or more coordinate systems,
\item statistical summarization rules,
\item a facet specification, i.\,e. the use of multiple similar subplots to look at
  subsets of the same data,
\item optional parameters that affect the layout and rendering, such text size, font and
  alignment, legend positions, and the like.
\end{enumerate}
%
In the examples above, Figures~\ref{rgraphics:fig:qplot1} and \ref{rgraphics:fig:qplot2}, the
dataset was \Robject{groupsize}, the variables were the numeric values as well as the
names of \Robject{groupsize}, which we mapped to the aesthetics $y$-axis and $x$-axis
respectively, the scale was linear on the $y$ and rank-based on the $x$-axis (the bars are
ordered alphanumerically and each has the same width), the geometric object was the
rectangular bar.

Items 4.--7.\ in the above list are optional. If you don't specify them, then the
Cartesian is used as the coordinate system, the statistical summary is the trivial one
(i.\,e., the identity), and no facets or subplots are made (we'll see examples later on, in
Section~\ref{rgraphics:sec:facets}).  The first three items are mandatory, you always need
to specify at least one of them: they are the minimal components of a valid
\CRANpkg{ggplot2} ``sentence''.

\begin{marginfigure}[-20mm]
\includegraphics[width=\linewidth]{chap3-r_figscp2layers2-1}
\caption{As Figure~\ref{rgraphics:fig:scp2layers1}, but in addition with points colored by
  the sample group (as in Figure~\ref{rgraphics:fig:qplot2}).
  We can now see that the expression values of the gene
  `r AnnotationDbi::select(mouse4302.db, "1418765_at", keytype = "PROBEID", columns = "SYMBOL")$SYMBOL` %$
  (whose mRNA is targeted by the probe 1418765\_at) are consistently high in the early time points,
  whereas its expression goes down in the EPI samples at days 3.5 and 4.5.
  In the FGF4-KO, this decrease is delayed - at E3.5, its expression is still high.
  Conversely, the gene
  `r AnnotationDbi::select(mouse4302.db, "1426642_at", keytype = "PROBEID", columns = "SYMBOL")$SYMBOL` %$
  (1426642\_at) is off in the early timepoints and then goes up at days 3.5 and 4.5.
  The PE samples (green) show a high degree of cell-to-cell variability.}
\label{rgraphics:fig:scp2layers2}
\end{marginfigure}
%
In fact, \CRANpkg{ggplot2}'s implementation of the grammar of graphics allows you to use
the same type of component multiple times, in what are called
layers~\citep{Wickham:LayeredGrammar}.  For example, the code below uses three types of
geometric objects in the same plot, for the same data: points, a line and a confidence
band.
%
```{r loadlib, echo = FALSE, message = FALSE}
library("mouse4302.db")
```
```{r findprobepairs, echo = FALSE, eval = FALSE}
# I used this code to find the below two probes
idx = order(rowVars(exprs(x)), decreasing=TRUE)[seq_len(2000)]
cc  = cor(t(exprs(x)[idx,]))
cco = order(cc)[seq(1, 1001, by=2) ]
jj2 = rownames(exprs(x))[ idx[ (cco-1) %/% length(idx) + 1 ] ]
jj1 = rownames(exprs(x))[ idx[ (cco-1) %%  length(idx) + 1 ] ]
dftx = as.data.frame(t(exprs(x)))
par(ask=TRUE)
for(i in seq(along = cco)) {
  df = AnnotationDbi::select(mouse4302.db,
   keys = c(jj1[i], jj2[i]), keytype = "PROBEID",
   columns = c("SYMBOL", "GENENAME"))
  print(ggplot(dftx, aes( x = get(jj1[i]), y = get(jj2[i]))) +
  geom_point(shape = 1) +
  xlab(paste(jj1[i], df$SYMBOL[1])) +
  ylab(paste(jj2[i], df$SYMBOL[2])) +
  ggtitle(round(cc[jj1[i], jj2[i]], 3)) +
  geom_smooth(method = "loess"))
}
```
```{r figscp2layers1, fig.width = 3.5, fig.height = 3.5}
# dftx = as_tibble(t(exprs(x))) %>% cbind(pData(x))
dftx = data.frame(t(exprs(x)), pData(x))
ggplot( dftx, aes( x = X1426642_at, y = X1418765_at)) +
  geom_point( shape = 1 ) +
  geom_smooth( method = "loess" )
```
%
Here we had to assemble a copy of the expression data (\Robject{exprs(x)}) and the sample annotation
data (\Robject{pData(x)}) all together into the dataframe \Robject{dftx} --
since this is the data format that \Rpackage{ggplot2} functions most easily take as input
(more on this in Section~\ref{Chap:Design:sec:datarep}).
```{r checkclassdftx, echo=FALSE}
stopifnot(is(dftx, "data.frame"))
```

We can further enhance the plot by using colors -- since each of the points in
Figure~\ref{rgraphics:fig:scp2layers1} corresponds to one sample, it makes sense to use
the \Robject{sampleColour} information in the object \Robject{x}.
%
```{r figscp2layers2, fig.width = 3.5, fig.height = 3.5}
ggplot( dftx, aes( x = X1426642_at, y = X1418765_at ))  +
  geom_point( aes( color = sampleColour), shape = 19 ) +
  geom_smooth( method = "loess" ) +
  scale_color_discrete( guide = FALSE )
```
%
\begin{ques}
In the code above we defined the \Robject{color} aesthetics
(\Robject{aes}) only for the \Robject{geom\_point} layer, while we defined the \Robject{x}
and \Robject{y} aesthetics for all layers. What happens if we set the \Robject{color}
aesthetics for all layers, i.\,e., move it into the argument list of \Rfunction{ggplot}?
What happens if we omit the call to \Rfunction{scale\_color\_discrete}?
\end{ques}

\begin{ques}
Is it always meaningful to visualize scatterplot data together with a regression
line as in Figures \ref{rgraphics:fig:scp2layers1} and \ref{rgraphics:fig:scp2layers2}?
\end{ques}

As a small side remark, if we want to find out which genes are targeted by these probe
identifiers, and what they might do, we can call.\footnote{Note that here were need to use
  the original feature identifiers (e.\,g., ``1426642\_at'', without the leading
  ``X''). This is the notation used by the microarray manufacturer, by the Bioconductor
  annotation packages, and also inside the object \Robject{x}. The leading ``X'' that we
  used above when working with \Robject{dftx} was inserted during the creation of
  \Robject{dftx} by the constructor fuction \Rfunction{data.frame}, since its
  argument \Robject{check.names} is set to \Robject{TRUE} by default.
  Alternatively, we could have kept the original
  identifer notation by setting \Robject{check.names=FALSE}, but then we would need to
  work with the backticks, such as \Robject{aes( x = \`{}1426642\_at\`{}, ...)}, to make
  sure R understands the identifiers correctly.}
% Remark, WH 16.5.2015: I tried this initially but then got difficult to trace errors in
% below code using facet_wrap ...
%
% "Note the downward-sloping quotation marks around the identifiers, 1426642\_at and
% 1418765\_at. R understands these quotation marks to indicate variable names (or, here,
% column names in the dataframe \Robject{dftx}), and they are needed since these
% identifiers would, without explicit quotation, not be valid variable names."
%
```{r mouse4302.db, results="hide", message=FALSE}
library("mouse4302.db")
```
```{r select}
AnnotationDbi::select(mouse4302.db,
   keys = c("1426642_at", "1418765_at"), keytype = "PROBEID",
   columns = c("SYMBOL", "GENENAME"))
```
%
Often when using \Rfunction{ggplot} you will only need to specify the data, aesthetics and a
geometric object. Most geometric objects implicitly call a suitable default statistical
summary of the data.
For example, if you are using \Robject{geom\_smooth}, \CRANpkg{ggplot2}
by default uses \Robject{stat = "smooth"} and then displays a line; if you use
\Robject{geom\_histogram}, the data are binned, and the result is displayed in barplot format.
Here's an example:
%
\begin{marginfigure}
\includegraphics[width=\linewidth]{chap3-r_fighists-1}
\caption{Histogram of probe intensities for one particular sample, cell number 20, which
was from day E3.25.}
\label{rgraphics:fig:hists}
\end{marginfigure}
%
```{r fighists, fig.width = 3.5, fig.height = 2.5}
dfx = as.data.frame(exprs(x))
ggplot(dfx, aes(x = `20 E3.25`)) + geom_histogram(binwidth = 0.2)
```
%
\begin{ques}
What is the difference between the objects \Robject{dfx} and \Robject{dftx}?
Why did we need to create both of the?
\end{ques}
%
Let's come back to the barplot example from above.
%
```{r figbpgg1}
pb = ggplot(groups, aes(x = sampleGroup, y = n))
```
%
This creates a plot object \Robject{pb}. If we try to display it,
it creates an empty plot, because we haven't specified what geometric object we want to use.
All that we have in our \Robject{pb} object so far are the data and the aesthetics
(Fig.~\ref{rgraphics:fig:figbpempty})
%
```{r figbpempty, fig.width = 3.2, fig.height = 2.5}
class(pb)
pb
```
%
\begin{marginfigure}[-5mm]
\includegraphics[width=\linewidth]{chap3-r_figbpempty-1}
\caption{\Robject{pb}: without a geometric object, the plot remains empty.}
\label{rgraphics:fig:figbpempty}
\end{marginfigure}
%
Now we can literally add on the other components of our plot through using the
\Robject{+} operator (Fig.~\ref{rgraphics:fig:bpgg3}):
%
```{r bpgg3, fig.width = 5, fig.height = 4}
pb = pb + geom_bar(stat = "identity")
pb = pb + aes(fill = sampleGroup)
pb = pb + theme(axis.text.x = element_text(angle = 90, hjust = 1))
pb = pb + scale_fill_manual(values = groupColor, name = "Groups")
pb
```
%
\begin{marginfigure}[0mm]
\includegraphics[width=\linewidth]{chap3-r_bpgg3-1}
\caption{The graphics object \Robject{bp} in its full glory.}
\label{rgraphics:fig:bpgg3}
\end{marginfigure}
%
This step-wise buildup --taking a graphics object already produced in
some way and then further refining it-- can be more convenient and easy to manage than,
say, providing all the instructions upfront to the single function call that creates the
graphic.  We can quickly try out different visualization ideas without having to rebuild
our plots each time from scratch, but rather store the partially finished object and then modify it in
different ways.  For example we can switch our plot to polar coordinates to create an
alternative visualization of the barplot.
%
```{r bpgg4, fig.width = 5, fig.height = 4}
pb.polar = pb + coord_polar() +
  theme(axis.text.x = element_text(angle = 0, hjust = 1),
        axis.text.y = element_blank(),
        axis.ticks = element_blank()) +
  xlab("") + ylab("")
pb.polar
```
%
\begin{marginfigure}
\includegraphics[width=\linewidth]{chap3-r_bpgg4-1}
\caption{A barplot in a polar coordinate system.}
\label{rgraphics:fig:bpgg7}
\end{marginfigure}
%
Note above that we can override previously set \Rfunction{theme} parameters by simply
setting them to a new value --
no need to go back to recreating \Robject{pb}, where we originally set them.

%------------------------------------------------------------
\section{Visualization of 1D data}
\label{rgraphics:sec:univar}
%------------------------------------------------------------
A common task in biological data analysis is the comparison between several samples
of univariate measurements. In this section we'll explore some possibilities for
visualizing and comparing such samples. As an example, we'll use the intensities of a set
of four genes Fgf4, Gata4, Gata6 and Sox2\footnote{You can read more about these
genes in the paper associated with the data.}. On the array, they are represented by
%
```{r genes2ps1}
selectedProbes = c( Fgf4 = "1420085_at", Gata4 = "1418863_at",
                   Gata6 = "1425463_at",  Sox2 = "1416967_at")
```
```{r genes2ps2, echo = FALSE, eval = FALSE}
# How I found the selectedProbes:
AnnotationDbi::select(mouse4302.db,
   keys = c("Fgf4", "Sox2", "Gata6", "Gata4"), keytype = "SYMBOL",
   columns = c("PROBEID"))
```
```{r genes2ps3, echo = FALSE}
selectedProbes2 = AnnotationDbi::select(mouse4302.db,
   keys = selectedProbes, keytype = "PROBEID", columns = c("SYMBOL"))
stopifnot(identical(sort(selectedProbes2$SYMBOL), sort(names(selectedProbes))),
          all(selectedProbes[selectedProbes2$SYMBOL] == selectedProbes2$PROBEID))
```
%$
To extract data from this representation and convert them into a dataframe, we use the
function \Rfunction{melt} from the \CRANpkg{reshape2} package\footnote{We'll talk more
  about the concepts and mechanics of different data representations in
  Section~\ref{Chap:Design:sec:datarep}.}.
%
```{r melt}
library("reshape2")
genes = melt(exprs(x)[selectedProbes, ], varnames = c("probe", "sample"))
head(genes)
```
%
For good measure, we also add a column that provides the gene symbol along with the probe identifiers.
%
```{r symbol}
genes$gene = names(selectedProbes)[ match(genes$probe, selectedProbes) ]
```

%------------------------------------------------------------
\subsection{Barplots}\label{rgraphics:sec:univar:bar}
%------------------------------------------------------------
\begin{marginfigure}
\begin{center}
\includegraphics[width=0.8\linewidth]{chap3-r_onedbp1-1}
\caption{Barplots showing the means of the distributions of expression measurements from 4 probes.}
\label{rgraphics:fig:onedbp1}
\end{center}
\end{marginfigure}
%
A popular way to display data such as in our dataframe \Robject{genes} is through barplots.
See Fig.~\ref{rgraphics:fig:onedbp1}.
```{r onedbp1, fig.width = 3, fig.height = 3.75}
ggplot(genes, aes( x = gene, y = value)) +
  stat_summary(fun.y = mean, geom = "bar")
```
%
In Figure~\ref{rgraphics:fig:onedbp1}, each bar represents the mean of the values for that gene. Such plots
are seen a lot in the biological sciences, as well as in the popular media. The data summarization
into only the mean looses a lot of information, and given the amount of space it takes, a barplot
can be a poor way to visualise data\footnote{In fact, if the mean is not an appropriate summary, such
as for highly skewed distributions, or datasets with outliers, the barplot can be
outright misleading.}.

Sometimes we want to add error bars, and one way to achieve this in \CRANpkg{ggplot2} is as follows.
%
```{r onedbp2, fig.width = 3.75, fig.height = 3.75}
library("Hmisc")
ggplot(genes, aes( x = gene, y = value, fill = gene)) +
  stat_summary(fun.y = mean, geom = "bar") +
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar",
               width = 0.25)
```
%
Here, we see again the principle of layered graphics: we use two summary functions,
\Rfunction{mean} and \Rfunction{mean\_cl\_normal}, and two associated geometric objects,
\Robject{bar} and \Robject{errorbar}. The function \Rfunction{mean\_cl\_normal} is from
the \CRANpkg{Hmisc} package and computes the standard error (or \textbf{c}onfidence
\textbf{l}imits) of the mean; it's a simple function, and we could also compute it
ourselves using base R expressions if we wished to do so.  We also colored the bars to
make the plot more pleasant.
%
\begin{marginfigure}
\includegraphics[width=\linewidth]{chap3-r_onedbp2-1}
\caption{Barplots with error bars indicating standard error of the mean.}
\label{rgraphics:fig:onedbp2}
\end{marginfigure}

%------------------------------------------------------------
\subsection{Boxplots}
%------------------------------------------------------------
It's easy to show the same data with boxplots.
%
```{r onedboxpl, fig.width = 3.75, fig.height = 3.75}
p = ggplot(genes, aes( x = gene, y = value, fill = gene))
p + geom_boxplot()
```
%
\begin{marginfigure}
\includegraphics[width=\linewidth]{chap3-r_onedboxpl-1}
\caption{Boxplots.}
\label{rgraphics:fig:onedboxpl}
\end{marginfigure}
%
Compared to the barplots, this takes a similar amount of space, but is much more
informative. In Figure~\ref{rgraphics:fig:onedboxpl} we see that two of the genes (Gata4, Gata6)
have relatively concentrated distributions, with only a few data points venturing out to
the direction of higher values. For Fgf4, we see that the distribution is right-skewed:
the median, indicated by the horizontal black bar within the box is closer to the lower (or
left) side of the box. Analogously, for Sox2 the distribution is left-skewed.

%------------------------------------------------------------
\subsection{Violin plots}
%------------------------------------------------------------

A variation of the boxplot idea, but with an even more direct representation of the shape
of the data distribution, is the violin plot. Here, the shape of the violin gives a rough
impression of the distribution density.

```{r onedviolin, fig.width = 3.75, fig.height = 3.75}
p + geom_violin()
```

%------------------------------------------------------------
\subsection{Dot plots and beeswarm plots}
%------------------------------------------------------------
\begin{marginfigure}
\includegraphics[width=\linewidth]{chap3-r_onedviolin-1}
\caption{Violin plots.}
\label{rgraphics:fig:onedviolin}
\end{marginfigure}
%
If the number of data points is not too large, it is possible to show the data points
directly, and it is good practice to do so, compared to using more abstract
summaries.
However, plotting the data directly will often lead to overlapping points, which can be
visually unpleasant, or even obscure the data. We can try to layout the points so that
they are as near possible to their proper locations without
overlap~\citep{Wilkinson:DotPlots:1999}.
%
```{r oneddot, fig.width = 5, fig.height = 5}
p + geom_dotplot(binaxis = "y", binwidth = 1/6,
       stackdir = "center", stackratio = 0.75,
       aes(color = gene))
```
%
The plot is shown in the left panel of Figure~\ref{rgraphics:fig:oneddot}. The $y$-coordinates of
the points are discretized into bins (above we chose a bin size of 1/6), and then they
are stacked next to each other.

An alternative is provided by the package \CRANpkg{ggbeeswarm}, which provides
\Rfunction{geom\_beeswarm}.
%
```{r onedbee, fig.width = 5, fig.height = 5}
library("ggbeeswarm")
p + geom_beeswarm(aes(color = gene))
```
%
\begin{figure}
\includegraphics[width=.49\linewidth]{chap3-r_oneddot-1}
\includegraphics[width=.49\linewidth]{chap3-r_onedbee-1}
\caption{Left: dot plots, made using \Rfunction{geom\_dotplot} from \CRANpkg{ggplot2}.
Right: beeswarm plots, made using \Rfunction{geom\_beeswarm} from \CRANpkg{ggbeeswarm}.}
\label{rgraphics:fig:oneddot}
\end{figure}
%
The plot is shown in the right panel of Figure~\ref{rgraphics:fig:oneddot}. The layout
algorithm tries to avoid overlaps between the points. If a point were to overlap an
existing point, it is shifted sideways (along the $x$-axis) by a small amount sufficient
to avoid overlap.  Some twiddling with layout parameters is usually needed for each new
dataset to make a dot plot or a beeswarm plot look good.

%------------------------------------------------------------
\subsection{Density plots}\label{rgraphics:sec:univar:dens}
%------------------------------------------------------------
Yet another way to represent the same data is by density plots
(Figure~\ref{rgraphics:fig:oneddens}).
%
```{r oneddens, fig.width = 3.75, fig.height = 3.75}
ggplot(genes, aes( x = value, color = gene)) + geom_density()
```
%
Density estimation has a number of complications, in particular, the need for choosing a
smoothing window. A window size that is small enough to capture peaks in the dense regions
of the data may lead to instable (``wiggly'') estimates elsewhere. On the other hand, if
the window is made bigger, pronounced features of the density, such as sharp peaks, may be
smoothed out.  Moreover, the density lines do not convey the information on how much data
was used to estimate them, and plots like Figure~\ref{rgraphics:fig:oneddens} can be
especially problematic if the sample sizes for the curves differ.

\begin{marginfigure}
\includegraphics[width=\linewidth]{chap3-r_oneddens-1}
\caption{Density plots.}
\label{rgraphics:fig:oneddens}
\end{marginfigure}
%

%------------------------------------------------------------
\subsection{ECDF plots}\label{rgraphics:sub:ecdf}
%------------------------------------------------------------
The mathematically most convenient way to describe the distribution of a one-dimensional
random variable $X$ is its cumulative distribution function (CDF), i.\,e., the function
\begin{equation}
F(x) = P(X\le x),
\end{equation}
where $x$ takes all values along the real axis. The density of $X$ is then the derivative
of $F$, if it exists\footnote{By its definition, $F$ tends to 0 for small $x$ ($x\to-\infty$) and
to 1 for large $x$ ($x\to+\infty$).}.  The definition of the CDF can also be
applied to finite samples of $X$, i.\,e., samples $x_1,\ldots,x_n$. The empirical
cumulative distribution function (ECDF) is simply (Figure~\ref{rgraphics:fig:onedecdf}):
\begin{equation}
F_{n}(x) = \frac{1}{n}\sum_{i=1}^n \mathbbm{1}_{x\le x_i}.
\end{equation}
%
```{r onedecdf, fig.width = 3.75, fig.height = 3.75}
ggplot(genes, aes( x = value, color = gene)) + stat_ecdf()
```
%
\begin{marginfigure}
\includegraphics[width=\linewidth]{chap3-r_onedecdf-1}
\caption{Empirical cumulative distribution functions (ECDF).}
\label{rgraphics:fig:onedecdf}
\end{marginfigure}
%
The ECDF has several nice properties:
\begin{itemize}
  \item It is lossless - the ECDF $F_{n}(x)$ contains all the information contained in the original
   sample  $x_1,\ldots,x_n$ (except the --unimportant-- order of the values).
 \item As $n$ grows, the ECDF $F_{n}(x)$ converges to the true CDF $F(x)$. Even for
   limited sample sizes $n$, the difference between the two functions tends to be
   small. Note that this is not the case for the empirical density! Without smoothing, the
   empirical density of a finite sample is a sum of Dirac delta functions, which is
   difficult to visualize and quite different from any underlying smooth, true density.
   With smoothing, the difference can be less pronounced, but is difficult to control, as
   we discussed above.
\end{itemize}


%------------------------------------------------------------
\subsection{The effect of transformations on densities}
%------------------------------------------------------------
\begin{marginfigure}
\includegraphics[width=0.8\linewidth]{chap3-r_onedtrsf-1}\\
\includegraphics[width=0.8\linewidth]{chap3-r_onedtrsf-2}
\caption{Histograms of the same data, with and without logarithmic transformation.
  The number of modes is different.}
\label{rgraphics:fig:onedtrsf}
\end{marginfigure}

It is tempting to look at histograms or density plots and inspect them for evidence of
bimodality (or multimodality) as an indication of some underlying biological phenomenon.
Before doing so, it is important to remember that the number of modes of a density depends
on scale transformations of the data, via the \eindex{chain rule}. A simple example, with a
mixture of two normal distributions, is shown in Figure~\ref{rgraphics:fig:onedtrsf}.
%
```{r gridExtra, echo = FALSE}
library("gridExtra")
```
```{r onedtrsf, fig.width = 3.75, fig.height = 3.5}
sim <- data_frame(
   x = exp(rnorm(
     n    = 1e5,
     mean = sample(c(2, 5), size = 1e5, replace = TRUE))))

ggplot(sim, aes(x)) +
    geom_histogram(binwidth = 10, boundary = 0) + xlim(0, 400)
ggplot(sim, aes(log(x))) + geom_histogram(bins = 30)
```
%
\begin{ques} Consider a log-normal mixture model as in the code above.  What is the
  density function of $X$? What is the density function of $log(X)$?  How many modes do
  these densities have, as a function of the parameters of the mixture model (mean and
  standard deviation of the component normals, and mixture fraction)?
\end{ques}
%
%------------------------------------------------------------
\section{Visualization of 2D data: scatterplots}
\label{rgraphics:sec:2d}
%------------------------------------------------------------
\begin{marginfigure}
\includegraphics[width=\linewidth]{chap3-r_twodsp1-1}
\caption{Scatterplot of `r nrow(dfx)` expression measurements for two of the samples.}
\label{rgraphics:fig:twodsp1}
\end{marginfigure}
%
Scatterplots are useful for visualizing treatment--response comparisons (as in
Figure~\ref{rgraphics:fig:basicplotting2}), associations between variables (as in
Figure~\ref{rgraphics:fig:scp2layers2}), or paired data (e.\,g., a disease biomarker in
several patients before and after treatment). We use the two dimensions of our plotting
paper, or screen, to represent the two variables.
Let us take a look at differential expression between a wildtype and an FGF4-KO sample.
%
```{r twodsp1, fig.width = 3.75, fig.height = 3.75, dev = "png"}
scp = ggplot(dfx, aes(x = `59 E4.5 (PE)` ,
                      y = `92 E4.5 (FGF4-KO)`))
scp + geom_point()
```
%
The labels \Robject{`r scp$labels$x`} and \Robject{`r scp$labels$y`} refer to column names
(sample names) in the dataframe \Robject{dfx}, which we created above. Since they contain
special characters (spaces, parentheses, hyphen) and start with numerals, we need to
enclose them with the downward sloping quotes to make them syntactically digestible for R.
The plot is shown in Figure~\ref{rgraphics:fig:twodsp1}.  We get a dense point cloud that
we can try and interpret on the outskirts of the cloud, but we really have no idea
visually how the data are distributed within the denser regions of the plot.

One easy way to ameliorate the overplotting is to adjust the transparency (alpha value) of
the points by modifying the \Robject{alpha} parameter of \Rfunction{geom\_point}
(Figure~\ref{rgraphics:fig:twodsp2}).
%
\begin{marginfigure}
\includegraphics[width=\linewidth]{chap3-r_twodsp2-1}
\caption{As Figure~\ref{rgraphics:fig:twodsp1}, but with semi-transparent points to resolve
some of the overplotting.}
\label{rgraphics:fig:twodsp2}
\end{marginfigure}
%
```{r twodsp2, fig.width = 3.75, fig.height = 3.75, dev = "png"}
scp  + geom_point(alpha = 0.1)
```
%
This is already better than Figure~\ref{rgraphics:fig:twodsp1}, but in the more dense regions
even the semi-transparent points quickly overplot to a featureless black mass, while the
more isolated, outlying points are getting faint.
An alternative is a contour plot of the 2D density,
which has the added benefit of not rendering all of the points on the plot, as in
Figure~\ref{rgraphics:fig:twodsp3}.
%
```{r twodsp3, fig.width = 3.75, fig.height = 3.75}
scp + geom_density2d()
```
\begin{marginfigure}
\includegraphics[width=\linewidth]{chap3-r_twodsp3-1}
\caption{As Figure~\ref{rgraphics:fig:twodsp1}, but rendered as a contour plot of the 2D density estimate.}
\label{rgraphics:fig:twodsp3}
\end{marginfigure}
%
However, we see in Figure~\ref{rgraphics:fig:twodsp3} that the point cloud at the bottom right (which
contains a relatively small number of points) is no longer represented. We can somewhat overcome
this by tweaking the bandwidth and binning parameters of \Rfunction{geom\_density2d}
(Figure~\ref{rgraphics:fig:twodsp4}, left panel).
%
```{r twodsp4, fig.width = 3.75, fig.height = 3.75}
scp + geom_density2d(h = 0.5, bins = 60)
```
%
We can fill in each space between the contour lines with the relative density of points by
explicitly calling the function \Rfunction{stat\_density2d} (for which
\Rfunction{geom\_density2d} is a wrapper) and using the geometric object \emph{polygon},
as in the right panel of Figure~\ref{rgraphics:fig:twodsp4}.
%
```{r twodsp5, fig.width = 5.25, fig.height = 3.75, message = FALSE}
library("RColorBrewer")
colorscale = scale_fill_gradientn(
    colors = rev(brewer.pal(9, "YlGnBu")),
    values = c(0, exp(seq(-5, 0, length.out = 100))))

scp + stat_density2d(h = 0.5, bins = 60,
          aes( fill = ..level..), geom = "polygon") +
  colorscale + coord_fixed()
```
%
\begin{figure}
\includegraphics[width=0.416\linewidth]{chap3-r_twodsp4-1}
\includegraphics[width=0.582\linewidth]{chap3-r_twodsp5-1}
\caption{Left: as Figure~\ref{rgraphics:fig:twodsp3}, but with smaller smoothing bandwidth and tighter
binning for the contour lines. Right: with color filling.}
\label{rgraphics:fig:twodsp4}
\end{figure}
%
We used the function \Rfunction{brewer.pal} from the package \CRANpkg{RColorBrewer} to
define the color scale, and we added a call to \Rfunction{coord\_fixed} to fix the
aspect ratio of the plot, to make sure that the mapping of data range to $x$- and
$y$-coordinates is the same for the two variables.
Both of these issues merit a deeper look, and we'll talk more about plot shapes in
Section~\ref{rgraphics:sec:banking} and about colors in Section~\ref{rgraphics:sec:color}.

The density based plotting methods in Figure~\ref{rgraphics:fig:twodsp4} are more visually
appealing and interpretable than the overplotted point clouds of
Figures~\ref{rgraphics:fig:twodsp1} and \ref{rgraphics:fig:twodsp2}, though we have to be careful in using
them as we loose a lot of the information on the outlier points in the sparser regions of
the plot. One possibility is using \Rfunction{geom\_point} to add such points back in.

But arguably the best alternative, which avoids the limitations of smoothing, is hexagonal
binning~\citep{Carr1987hexbin}.

%
```{r twodsp6, fig.width = 5.25, fig.height = 3.75}
scp + geom_hex() + coord_fixed()
scp + geom_hex(binwidth = c(0.2, 0.2)) + colorscale +
  coord_fixed()
```
%
\begin{figure}
\includegraphics[width=0.499\linewidth]{chap3-r_twodsp6-1}
\includegraphics[width=0.499\linewidth]{chap3-r_twodsp6-2}
\caption{Hexagonal binning. Left: default parameters. Right: finer bin sizes and
  customized color scale.}
\label{rgraphics:fig:twodsp6}
\end{figure}


%------------------------------------------------------------
\subsection{Plot shapes}
\label{rgraphics:sec:banking}
%------------------------------------------------------------
Choosing the proper shape for your plot is important to make sure the information is
conveyed well. By default, the shape parameter, that is, the ratio, between the height of
the graph and its width, is chosen by \CRANpkg{ggplot2} based on the available space in
the current plotting device. The width and height of the device are specified when it is
opened in R, either explicitly by you or through default parameters\footnote{E.\,g., see
  the manual pages of the \Rfunction{pdf} and \Rfunction{png} functions.}. Moreover, the
graph dimensions also depend on the presence or absence of additional decorations, like
the color scale bars in Figure~\ref{rgraphics:fig:twodsp6}.

There are two simple rules that you can apply for scatterplots:
\begin{itemize}
\item If the variables on the two axes are measured in the same units, then make sure that
  the same mapping of data space to physical space is used -- i.\,e., use
  \Rfunction{coord\_fixed}.  In the scatterplots above, both axes are the logarithm
  to base 2 of expression level measurements, that is a change by one unit has the same
  meaning on both axes (a doubling of the expression level). Another case is principal
  component analysis (PCA), where the $x$-axis typically represents component 1, and the
  $y$-axis component 2. Since the axes arise from an orthonormal rotation of input data
  space, we want to make sure their scales match. Since the variance of the data is (by
  definition) smaller along the second component than along the first component (or at
  most, equal), well-done PCA plots usually have a width that's larger than the height.
\item If the variables on the two axes are measured in different units, then we can still
  relate them to each other by comparing their dimensions. The default in many plotting
  routines in R, including \CRANpkg{ggplot2}, is to look at the range of the data and map
  it to the available plotting region. However, in particular when the data more or less
  follow a line, looking at the typical slope of the line can be useful.
  This is called banking~\citep{Cleveland:1988:Banking}.
\end{itemize}
To illustrate banking, let's use the classic sunspot data from Cleveland's paper.
%
\begin{marginfigure}
\includegraphics[width=\linewidth]{chap3-r_banking1-1}\\
\includegraphics[width=\linewidth]{chap3-r_banking2-1}
\caption{The sunspot data. In the upper panel, the plot shape is roughly quadratic, a
  frequent default choice. In the lower panel, a technique called \emph{banking} was used
  to choose the plot shape.}
\label{rgraphics:fig:banking}
\end{marginfigure}
%
```{r banking1, fig.width = 3.75, fig.height = 3.75}
library("ggthemes")
sunsp = tibble(year   = time(sunspot.year),
               number = as.numeric(sunspot.year))
sp = ggplot(sunsp, aes(x = year, y = number)) + geom_line()
sp
```
%
The resulting plot is shown in the upper panel of Figure~\ref{rgraphics:fig:banking}. We can
clearly see long-term fluctuations in the amplitude of sunspot activity cycles, with
particularly low maximum activities in the early 1700s, early 1800s, and around the turn
of the 20$^\text{th}$ century. But now lets try out banking.
%
```{r banking2, fig.width = 3.75, fig.height = 2}
ratio = with(sunsp, bank_slopes(year, number))
sp + coord_fixed(ratio = ratio)
```
%
What the algorithm does is to look at the slopes in the curve, and in particular, the
above call to \Rfunction{bank\_slopes} computes the median absolute slope, and then with
the call to \Robject{coord\_fixed} we shape the plot such that this quantity becomes
1. The result is shown in the lower panel of Figure~\ref{rgraphics:fig:banking}. Quite
counter-intuitively, even though the plot takes much smaller space, we see more on it!
Namely, we can see the saw-tooth shape of the sunspot cycles, with sharp rises and more
slow declines.


%------------------------------------------------------------
\section{3--5D data}
\label{rgraphics:sec:facets}
%------------------------------------------------------------
Sometimes we want to show the relations between more than two variables. Obvious choices
for including additional dimensions are the plot symbol shapes and colors. The
\Rfunction{geom\_point} geometric object offers the following aesthetics (beyond
\Robject{x} and \Robject{y}):
\begin{itemize}
\item \Robject{fill}
\item \Robject{color}
\item \Robject{shape}
\item \Robject{size}
\item \Robject{alpha}
\end{itemize}
They are explored in the manual page of the \Rfunction{geom\_point}
function. \Robject{fill} and \Robject{color} refer to the fill and outline color of an
object, \Robject{alpha} to its transparency level. Above, in
Figures~\ref{rgraphics:fig:twodsp2} and following, we have used color or transparency to
reflect point density and avoid the obscuring effects of overplotting. Instead, we can use
them show other dimensions of the data (but of course we can only do one or the other). In
principle, we could use all the 5 aesthetics listed above simultaneously to show up to
7-dimensional data; however, such a plot would be hard to decipher, and usually we are
better off with sticking to at most one or two additional dimensions and mapping them to a
choice of the available aesthetics.

%------------------------------------------------------------
\subsection{Faceting}
%------------------------------------------------------------

Another way to show additional dimensions of the data is to show multiple plots that
result from repeatedly subsetting (or ``slicing'') our data based on one (or more) of the
variables, so that we can visualize each part separately. So we can, for instance,
investigate whether the observed patterns among the other variables are the same or
different across the range of the faceting variable. Let's look at an example\footnote{The
  first two lines this code chunk are not strictly necessary -- they're just reformatting
  the \Robject{lineage} column of the \Robject{dftx} dataframe, to make the
  plots look better.}
%
```{r facet1, fig.width = 8, fig.height = 2}
library("magrittr")
dftx$lineage %<>% sub("^$", "no", .)
dftx$lineage %<>% factor(levels = c("no", "EPI", "PE", "FGF4-KO"))

ggplot(dftx, aes( x = X1426642_at, y = X1418765_at)) +
  geom_point() + facet_grid( . ~ lineage )
```
%$
\begin{figure}
\includegraphics[width=\linewidth]{chap3-r_facet1-1}
\caption{An example for \emph{faceting}: the same data as in
  Figure~\ref{rgraphics:fig:scp2layers1}, but now split by the categorical variable
  \Robject{lineage}.}
\label{rgraphics:fig:facet1}
\end{figure}
%
The result is shown in Figure~\ref{rgraphics:fig:facet1}. We used the formula
language to specify by which variable we want to do the splitting, and that the separate
panels should be in different columns: \Robject{facet\_grid( . $\sim$ lineage )}. In fact, we
can specify two faceting variables, as follows; the result is shown in
Figure~\ref{rgraphics:fig:facet2}.
%
```{r facet2, fig.width = 8, fig.height = 6}
ggplot( dftx,
  aes( x = X1426642_at, y = X1418765_at)) + geom_point() +
   facet_grid( Embryonic.day ~ lineage )
```
%
\begin{figure}
  \begin{center}
\includegraphics[width=.8\linewidth]{chap3-r_facet2-1}
\caption{\emph{Faceting}: the same data as in Figure~\ref{rgraphics:fig:scp2layers1},
  split by the categorical variables \Robject{Embryonic.day} (rows) and \Robject{lineage}
  (columns).}
\label{rgraphics:fig:facet2}
  \end{center}
\end{figure}
%
Another useful function is \Rfunction{facet\_wrap}: if the faceting variable has too many
levels for all the plots to fit in one row or one column, then this function can be used
to wrap them into a specified number of columns or rows.

We can use a continuous variable by discretizing it into levels. The function
\Rfunction{cut} is useful for this purpose.
%
```{r facet3, fig.width = 4, fig.height = 4}
ggplot(mutate(dftx, Tdgf1 = cut(X1450989_at, breaks = 4)),
   aes( x = X1426642_at, y = X1418765_at)) + geom_point() +
   facet_wrap( ~ Tdgf1, ncol = 2 )
```
%
We see in Figure~\ref{rgraphics:fig:facet3} that the number of points in the four
panel is different, this is because \Rfunction{cut} splits into bins of equal length, not
equal number of points. If we want the latter, then we can use \Rfunction{quantile} in
conjunction with \Rfunction{cut}.

\begin{marginfigure}
\includegraphics[width=\linewidth]{chap3-r_facet3-1}
\caption{\emph{Faceting}: the same data as in Figure~\ref{rgraphics:fig:scp2layers1},
  split by the continuous variable \Robject{X1450989\_at} and arranged by
  \Rfunction{facet\_wrap}.}
\label{rgraphics:fig:facet3}
\end{marginfigure}

\paragraph{Axes scales}
In Figures~\ref{rgraphics:fig:facet1}--\ref{rgraphics:fig:facet3}, the axes
scales are the same for all plots.  Alternatively, we could let them vary by setting the
\Robject{scales} argument of the \Rfunction{facet\_grid} and \Rfunction{facet\_wrap}; this
parameters allows you to control whether to leave the $x$-axis, the $y$-axis, or both to
be freely variable. Such alternatives scalings might allows us to see the full detail of
each plot and thus make more minute observations about what is going on in each. The
downside is that the plot dimensions are not comparable across the groupings.

\paragraph{Implicit faceting} You can also facet your plots (without explicit
calls to \Rfunction{facet\_grid} and \Rfunction{facet\_wrap}) by specifying the
aesthetics. A very simple version of implicit faceting is using a factor as your $x$-axis,
such as in Figures~\ref{rgraphics:fig:onedbp1}--\ref{rgraphics:fig:oneddot}

%------------------------------------------------------------
\subsection{Interactive graphics}
%------------------------------------------------------------
The plots generated thus far have been static images. You can add an enormous amount of
information and expressivity by making your plots interactive. It is impossible here for
us to convey interactive visualizations, but we provide pointers to some important
resources.

\subsubsection{shiny}
Rstudio's \CRANpkg{shiny} is a web application framework for R. It makes it easy to create
interactive displays with sliders, selectors and other control elements that allow
changing all aspects of the plot(s) shown -- since the interactive elements call back
directly into the R code that produces the plot(s). See the
\href{http://shiny.rstudio.com/gallery/}{shiny gallery} for some great examples.

\subsubsection{ggvis}
\CRANpkg{ggvis} is a graphics system for R that builds upon \CRANpkg{shiny} and has an
underlying theory, look-and-feel and programming interface similar to
\CRANpkg{ggplot2}.

As a consequence of interactivity in \CRANpkg{shiny} and \CRANpkg{ggvis}, there needs to
be an R interpreter running with the underlying data and code to respond to the user's
actions while she views the graphic. This R interpreter could be on the local machine, or
on a server; in both cases, the viewing application is a web browser, and the interaction
with R goes through web protocols (http, or https). That is, of course, different from a
regular static graphic in a PDF file or in an HTML report, which is produced once and can
then be viewed without any

\subsubsection{plotly}
A great web-based tool for interactive graphic generation is \eindex{plotly}.  You can
view some examples of interactive graphics online at \url{https://plot.ly/r}.
To create your own interactive plots in R, you can use code like
%
```{r plotly, eval = FALSE}
library("plotly")
plot_ly(economics, x = date, y = unemploy / pop)
```
%
Like with \CRANpkg{shiny} and \CRANpkg{ggvis}, the graphics are viewed in an HTML browser,
however, no running R session is required. The graphics are self-contained HTML documents
whose ``logic'' is coded in JavaScript, or more precisly, in the D3.js system.

\subsubsection{rgl, webgl}
For visualising 3D objects (say, a geometrical structure), there is the package
\CRANpkg{rgl}.  It produces interactive viewer windows (either in specialized graphics
device on your screen, or through a web browser) in which you can rotate the scene, zoom
and in out, etc. An screenshot of the scene produced by the code below is shown in
Figure~\ref{rgraphics:fig:rglvolcano}.
%
\begin{marginfigure}
\includegraphics{chap3-rglvolcano}
% NOTE: included here is not the output of the code chunk below, but a pre-cooked version
% from the ../../images directory, b/c I couldn't figure out how to preset theta and phi.
\caption{\CRANpkg{rgl} rendering of the \Robject{volcano} data, the topographic
  information for Maunga Whau (Mt Eden), one of about 50 volcanos in the Auckland volcanic
  field.}
\label{rgraphics:fig:rglvolcano}
\end{marginfigure}
%
```{r volcano1}
data("volcano")
volcanoData = list(
  x = 10 * seq_len(nrow(volcano)),
  y = 10 * seq_len(ncol(volcano)),
  z = volcano,
  col = terrain.colors(500)[cut(volcano, breaks = 500)]
)
library("rgl")
with(volcanoData, persp3d(x, y, z, color = col))
```{r volcano2, echo = FALSE}
rgl.snapshot(filename = file.path("figure", "chap3-r_rglvolcano.png"))
```
```{r volcano3, echo = FALSE}
.volcanocut = cut(volcano, breaks = 500)
stopifnot(!any(is.na(.volcanocut)), all(as.integer(.volcanocut) %in% 1:500))
```
%
In the code above, the base R function \Rfunction{cut} computes a mapping from the value
range of the \Robject{volcano} data to the integers between 1 and 500\footnote{More
  precisely, it returns a factor with as many levels, which we let R autoconvert
  to integers.}, which we use to index the color scale, \Robject{terrain.colors(500)}.

For more information, consult the package's excellent vignette.

% From Vlad, not sure we need this here:
%
% For example if you want to plot the surface of Rosenbrock function
% (Figure~\ref{graphics:fig:rosenbrock}):}
% \[
% f (x, y) = (a  x)2 + b(y  x2)2
% \]
% ```{r rosenbrock, fig.width = 3, fig.height = 3, eval = FALSE}
% library("rgl")
% rx = seq(  -2, 2, length.out = 100)
% ry = seq(-0.5, 3, length.out = 100)
% rosenbrock = function(x, y) (1 - x^2) + (y - x^2)^2
% f_xy = outer(rx, ry, rosenbrock)
% colors = rainbow(200, start = 0/6, end = 4/6)
% persp3d(rx, ry, f_xy, col = colors[cut(f_xy, length(colors))])
% ```
%
% \begin{marginfigure}
% \includegraphics{chap3-r_rosenbrock-1}
% \caption{rosenbrock.}
% \label{graphics:fig:rosenbrock}
% \end{marginfigure}

%------------------------------------------------------------
\section{Color}
\label{rgraphics:sec:color}
%------------------------------------------------------------
\begin{marginfigure}
\begin{center}
\includegraphics[width=0.7\linewidth]{chap3-r_simplecolorpieDo-1}
\caption{Basic R colors. }
\label{rgraphics:fig:simplecolorpie}
\end{center}
\end{marginfigure}
An important consideration when making plots is the coloring that we use in them.  Most R
users are likely familiar with the built-in R color scheme, used by base R graphics, as
shown in Figure~\ref{rgraphics:fig:simplecolorpie}.

```{r simplecolorpieDo, fig.width = exp(1), fig.height = exp(1), eval = TRUE, echo = FALSE}
par(mai = rep(0,4))
pie(rep(1, 8), col=1:8)
```
```{r simplecolorpieShow, eval = FALSE, echo = TRUE}
pie(rep(1, 8), col=1:8)
```

These color choices date back from 1980s hardware, where graphics cards handled colors by
letting each pixel either fully use or not use each of the three basic color channels of
the display: red, green and blue (RGB): this leads to $2^3=8$ combinations, which lie at
the 8 the extreme corners of the RGB color cube\footnote{Thus the $8^\text{th}$ color
  should be white; in R, this was replaced by grey, as you can see in
  Figure~\ref{rgraphics:fig:simplecolorpie}.}. The colors in
Figure~\ref{rgraphics:fig:simplecolorpie} are harsh on the eyes, and there is no good
excuse any more for creating graphics that are based on this palette. Fortunately, the
default colors used by some of the more modern visualization oriented packages (including
\CRANpkg{ggplot2}) are much better already, but sometimes we want to make our own choices.

In Section~\ref{rgraphics:sec:2d} we saw the function \Rfunction{scale\_fill\_gradientn},
which allowed us to create the color gradient used in Figures \ref{rgraphics:fig:twodsp4}
and \ref{rgraphics:fig:twodsp6} by interpolating the basic color palette defined by the
function \Rfunction{brewer.pal} in the \CRANpkg{RColorBrewer} package. This package
defines a great set of color palettes. We can see all of them at a glance by using the
function \Rfunction{display.brewer.all} (Figure~\ref{rgraphics:fig:RColorBrewer}).
%
\begin{marginfigure}[-10mm]
\includegraphics[width=\linewidth]{chap3-r_RColorBrewer-1}
\caption{RColorBrewer palettes.}
\label{rgraphics:fig:RColorBrewer}
\end{marginfigure}
%
```{r RColorBrewer, fig.width=4, fig.height=7}
display.brewer.all()
```
%
We can get information about the available color palettes from \Robject{brewer.pal.info}.
%
```{r color3}
head(brewer.pal.info)
table(brewer.pal.info$category)
```
%$
The palettes are divided into three categories:
\begin{itemize}
\item qualitative: for categorical properties that have no intrinsic ordering. The
  \Robject{Paired} palette supports up to 6 categories that each fall into two
  subcategories - like \emph{before} and \emph{after}, \emph{with} and \emph{without}
  treatment, etc.
\item sequential: for quantitative properties that go from \emph{low} to \emph{high}
\item diverging: for quantitative properties for which there is a natural midpoint or
  neutral value, and whose value can deviate both up- and down; we'll see an example in
  Figure~\ref{rgraphics:fig:heatmap}.
\end{itemize}
To obtain the colors from a particular palette we use the function
\Rfunction{brewer.pal}. Its first argument is the number of colors we want (which can be
less than the available maximum number in \Robject{brewer.pal.info}).
%
```{r color4}
brewer.pal(4, "RdYlGn")
```
%
If we want more than the available number of preset colors (for example so we can plot a
heatmap with continuous colors) we can interpolate using the \Rfunction{colorRampPalette}
function\footnote{\Rfunction{colorRampPalette} returns a function of one parameter, an
  integer. In the code shown, we call that function with the argument \Robject{100}.}.
%
\begin{marginfigure}
\includegraphics[width=\linewidth]{chap3-r_colorRampPalette-1}
\caption{A quasi-continuous color palette derived by interpolating between the colors
  \Robject{darkorange3}, \Robject{white} and \Robject{darkblue}.}
\label{rgraphics:fig:colorRampPalette}
\end{marginfigure}
%
```{r colorRampPalette, fig.width = 3, fig.height = .7}
mypalette  = colorRampPalette(c("darkorange3", "white", "darkblue"))(100)
head(mypalette)
par(mai = rep(0.1, 4))
image(matrix(1:100, nrow = 100, ncol = 10), col = mypalette,
        xaxt = "n", yaxt = "n", useRaster = TRUE)
```

%--------------------------------------------------
\section{Heatmaps}
%--------------------------------------------------
Heatmaps are a powerful of visualising large, matrix-like datasets and giving a quick
overview over the patterns that might be in there. There are a number of heatmap drawing
functions in R; one that is convenient and produces good-looking output is the function
\Rfunction{pheatmap} from the eponymous package\footnote{A very versatile and modular
  alternative is the \Biocpkg{ComplexHeatmap} package.}. In the code below, we first
select the top 500 most variable genes in the dataset \Robject{x} and define a function
\Rfunction{rowCenter} that centers each gene (row) by subtracting the mean across
columns. By default, \Rfunction{pheatmap} uses the \emph{RdYlBu} color palette
from \CRANpkg{RcolorBrewer} in
conjuction with the \Rfunction{colorRampPalette} function to interpolate the
`r brewer.pal.info["RdYlBu", "maxcolors"]` color into a smooth-looking palette
(Figure~\ref{rgraphics:fig:heatmap}).
%
```{r heatmap, fig.width = 7, fig.height = 7}

library("pheatmap")
topGenes = order(rowVars(exprs(x)), decreasing = TRUE)[ seq_len(500) ]
rowCenter = function(x) { x - rowMeans(x) }
pheatmap( rowCenter(exprs(x)[ topGenes, ] ),
  show_rownames = FALSE, show_colnames = FALSE,
  breaks = seq(-5, +5, length = 101),
  annotation_col =
    pData(x)[, c("sampleGroup", "Embryonic.day", "ScanDate") ],
  annotation_colors = list(
    sampleGroup = groupColor,
    genotype = c(`FGF4-KO` = "chocolate1", `WT` = "azure2"),
    Embryonic.day = setNames(brewer.pal(9, "Blues")[c(3, 6, 9)],
                             c("E3.25", "E3.5", "E4.5")),
    ScanDate = setNames(brewer.pal(nlevels(x$ScanDate), "YlGn"),
                        levels(x$ScanDate))
  ),
  cutree_rows = 4
)
```
%
\begin{figure}
\includegraphics[width=.9\linewidth]{chap3-r_heatmap-1}
\caption{A heatmap of relative expression values, i.\,e., $\log_2$ fold change compared to
  the average expression of that gene (row) across all samples (columns). The color scale
  uses a diverging palette, whose neutral midpoint is at 0.}
\label{rgraphics:fig:heatmap}
\end{figure}
%
Let us take a minute to deconstruct this rather massive-looking call to
\Rfunction{pheatmap}.  The options \Robject{show\_rownames} and \Robject{show\_colnames}
control whether the row and column names are printed at the sides of the matrix. Because
our matrix is large in relation to the available plotting space, the labels would anyway
not be readable, and we suppress them. The \Robject{annotation\_col} argument takes a data
frame that carries
% whose rows match the samples (matrix columns), and whose columns can carry
additional information about the samples. The information is shown in the colored bars on
top of the heatmap. There is also a similar \Robject{annotation\_row} argument, which we
haven't used here, for colored bars at the side. \Robject{annotation\_colors} is a list
of named vectors by which we can override the default choice of colors for the annotation
bars. Finally, with the \Robject{cutree\_rows} argument we cut the row dendrogram into
four (an arbitrarily chosen number) clusters, and the heatmap shows them by leaving a bit
of white space in between.  The \Rfunction{pheatmap} function has many further options,
and if you want to use it for your own data visualizations, it's worth studying them.
%

%--------------------------------------------------
\subsection{Dendrogram ordering}
%--------------------------------------------------
The ordering of the rows and columns in a heatmap has an enormous impact on the visual
impact it makes, and it can be difficult to decide which patterns are real, and which are
consequences of arbitrary layout decisions\footnote{In Chapter~\ref{Chap:6}, we will learn
  about formal methods for evaluating cluster significance.}. Let's keep in mind that:
\begin{itemize}
\item Ordering the rows and columns by cluster dendrogram (as in
  Figure~\ref{rgraphics:fig:heatmap}) is an arbitrary choice, and you could just as well
  make other choices.
\item Even if you settle on dendrogram ordering, there is an essentially arbitrary choice
  at each internal branch, as each branch could be flipped without changing the topology
  of the tree.
\end{itemize}

\begin{ques}
  What other ordering methods can you think of?
\end{ques}
\begin{answer}
  Among the methods proposed is the travelling salesman
  problem~\citep{McCormick:1972:MatrixClustering} or projection on the first principal
  component (for instance, see the examples in the manual page of \Rfunction{pheatmap}).
\end{answer}

\begin{ques}
  Check the manual page of the \Rfunction{hclust} function (which, by default, is used by
  \Rfunction{pheatmap}) for how it deals with the decision of how to pick which branches
  of the subtree go left and right.
\end{ques}
\begin{ques}
  Check the argument \Robject{clustering\_callback} of the \Rfunction{pheatmap} function.
\end{ques}

%--------------------------------------------------
\subsection{Color spaces}
\label{rgraphics:sec:colorspaces}
%--------------------------------------------------

Color perception in humans~\citep{Helmholtz:1867} is three-dimensional\footnote{Physically,
  there is an infinite number of wave-lengths of light and an infinite number of ways of
  mixing them, so other species, or robots, can perceive less or more than three colors.}.
There are different ways of parameterizing this space.  Above we already
encountered the RGB color model, which uses three values in [0,1], for instance at the
beginning of Section~\ref{rgraphics:sec:ggplot}, where we printed out the contents of
\Robject{groupColor}:
%
```{r groupColor2}
groupColor[1]
```
```{r hexvals, echo = FALSE}
hexvals = sapply(1:3, function(i) substr(groupColor[1], i*2, i*2+1))
decvals = strtoi(paste0("0x", hexvals))
```
%
Here, `r hexvals[1]` is the hexadecimal representation for the strength of the red color
channel, `r hexvals[2]` of the green and `r hexvals[3]` of the green color channel. In
decimal, these numbers are `r decvals[1]`, `r decvals[2]` and `r decvals[3]`,
respectively. The range of these values goes from to 0 to 255, so by dividing by this
maximum value, an RGB triplet can also be thought of as a point in the three-dimensional
unit cube.
%
```{r somecolors, echo = FALSE, results = "hide"}
library("colorspace")
library("grid")

plothcl = function(h, c, l, what, x0 = 0.5, y0 = 0.5, default.units = "npc", ...) {
  switch(what,
         "c" = {
           stopifnot(length(l)==1)
           n = length(c)
         },
         "l" = {
           stopifnot(length(c)==1)
           n = length(l)
         },
         stop("Sapperlot"))

  cr = seq(0.1, 0.5, length = n+1)
  dr = 0.05 / n

  for (j in seq_len(n)) {
    r = c(cr[j]+dr, cr[j+1]-dr)
    for(i in 1:(length(h)-1)){
      phi = seq(h[i], h[i+1], by=1)/180*pi
      px = x0 + c(r[1]*cos(phi), r[2]*rev(cos(phi)))
      py = y0 + c(r[1]*sin(phi), r[2]*rev(sin(phi)))
      mycol = switch(what,
        "c" = hcl(h=mean(h[i+(0:1)]), c=c[j], l=l),
        "l" = hcl(h=mean(h[i+(0:1)]), c=c, l=l[j]))
      grid.polygon(px, py, gp=gpar(col=mycol, fill=mycol),
                   default.units=default.units,...)
    }
  }
}
```
```{r hcl, fig.width = 3.6, fig.height = 3.6, echo = FALSE}
plothcl( h = seq(0, 360, by=3), c = seq(5, 75, by=10), l = 75,   what="c")
grid.newpage()
plothcl( h = seq(0, 360, by=3), c = 55, l = seq(20, 100, by=10), what="l")
```
%
The function \Rfunction{hcl} uses a different coordinate system, which consists of the
three coordinates hue $H$, an angle in $[0, 360]$, chroma $C$, and lightness $L$ as a
value in $[0, 100]$. The possible values for $C$ depend on some constraints, but are
generally between 0 and 255.
\begin{marginfigure}
\includegraphics[width=\linewidth]{chap3-r_hcl-1}\\
\includegraphics[width=\linewidth]{chap3-r_hcl-2}
\caption{\label{rgraphics:fig:hcl}Circles in HCL colorspace.
  Upper panel: The luminosity $L$ is fixed to $75$, while the angular
  coordinate $H$ (hue) varies from 0 to 360 and the radial coordinate $C=0, 10,
  \ldots, 60$. Lower panel: constant chroma $C=50$, $H$ as above, and varying luminosity
  $L=10, 20, \ldots, 90$.}
\end{marginfigure}
The \Rfunction{hcl} function corresponds to polar coordinates
in the CIE-LUV\footnote{CIE: Commission Internationale de l'\'Eclairage -- see
  e.\,g.\ Wikipedia for more on this.} and is designed for area fills. By keeping chroma
and luminescence coordinates constant and only varying hue, it is easy to produce color
palettes that are harmonious and avoid irradiation illusions that make light colored
areas look bigger than dark ones. Our attention also tends to get drawn to loud colors,
and fixing the value of chroma makes the colors equally attractive to our eyes.

There are many ways of choosing colors from a color wheel. \emph{Triads} are three colors
chosen equally spaced around the color wheel; for example, $H=0, 120, 240$ gives red,
green, and blue.  \emph{Tetrads} are four equally spaced colors around the color wheel,
and some graphic artists describe the effect as "dynamic".  \emph{Warm colors} are a set
of equally spaced colors close to yellow, \emph{cool colors} a set of equally spaced
colors close to blue.  \emph{Analogous color} sets contain colors from a small segment of
the color wheel, for example, yellow, orange and red, or green, cyan and blue.
\emph{Complementary colors} are colors diametrically opposite each other on the color
wheel. A tetrad is two pairs of complementaries.  \emph{Split complementaries} are three
colors consisting of a pair of complementaries, with one partner split equally to each
side, for example, $H=60,\,240-30,\,240+30$.  This is useful to emphasize the difference
between a pair of similar categories and a third different one. A more thorough discussion
is provided in the references~\citep{Mollon:1995,IhakaColorPres}.

\subsubsection{Lines vs areas}
For lines and points, we want that they show a strong contrast to the background, so on a
white background, we want them to be relatively dark (low lightness $L$). For area fills,
lighter, more pastell-type colors with low to moderate chromatic content are usually more
pleasant.

%------------------------------------------------------------
\section{Data transformations}
%------------------------------------------------------------
Plots in which most points are huddled up in one area,
with a lot of sparsely populated space, are difficult to read. If the histogram of the
marginal distribution of a variable has a sharp peak and then long tails to one or both
sides, transforming the data can be helpful. These considerations apply both to
\Robject{x} and \Robject{y} aesthetics, and to color scales. In the plots of this chapter
that involved the microarray data, we used the logarithmic transformation\footnote{We used
  it implicitly since the data in the \Rclass{ExpressionSet} object \Robject{x} already
  come log-transformed.} -- not only in scatterplots like
Figure~\ref{rgraphics:fig:twodsp1} for the $x$ and $y$-coordinates, but also in
Figure~\ref{rgraphics:fig:heatmap} for the color scale that represents the expression
fold changes. The logarithm transformation is attractive because it has a definitive
meaning - a move up or down by the same amount on a log-transformed scale corresponds to
the same multiplicative change on the original scale: $\log(ax)=\log a+\log x$.

Sometimes the logarithm however is not good enough, for instance when the data include
zero or negative values, or when even on the logarithmic scale the data distribution is
highly uneven. From the upper panel of Figure~\ref{rgraphics:fig:MA}, it is easy to take away the
impression that the distribution of \Robject{M} depends on \Robject{A}, with higher
variances for lower \Robject{A}. However, this is entirely a visual artefact, as the lower
panel confirms: the distribution of \Robject{M} is independent of \Robject{A}, and the
apparent trend we saw in the upper panel was caused by the higher point density at
smaller \Robject{A}.
%
\begin{marginfigure}
\includegraphics[width=\linewidth]{chap3-r_MA-1}\\
\includegraphics[width=\linewidth]{chap3-r_MA-2}
\caption{The effect of rank transformation on the visual perception of dependency.}
\label{rgraphics:fig:MA}
\end{marginfigure}
%
```{r MA, fig.width = 3.75, fig.height = 3.75, dev = "png"}
gg = ggplot(tibble(
  A = exprs(x)[, 1],
  M = rnorm(length(A))),
  aes(y = M))
gg + geom_point(aes(x = A))
gg + geom_point(aes(x = rank(A)))
```
%
\begin{ques} Can the visual artefact be avoided by using a density- or binning-based
plotting method, as in Figure~\ref{rgraphics:fig:twodsp6}?
\end{ques}
%\begin{answer}
%```{r MA2, fig.width = 4.5, fig.height = 3.75}
%gg + geom_hex(aes(x = A))
%gg + geom_hex(aes(x = rank(A)))
%```
%\end{answer}

\begin{ques}
Can the rank transformation also be applied when choosing color scales e.\,g.\
  for heatmaps? What does \emph{histogram equalization} in image processing do?
\end{ques}

%------------------------------------------------------------
\section{Mathematical symbols and other fonts}
%------------------------------------------------------------
We can use mathematical notation in plot labels, using a notation that is a mix of R syntax and \LaTeX-like
notation (see \Robject{help("plotmath")} for details):
%
```{r mathnot, fig.width = 3, fig.height = 2.5}
volume = function(rho, nu)
            pi^(nu/2) * rho^nu / gamma(nu/2+1)

ggplot(tibble(nu    = 1:15,
  Omega = volume(1, nu)), aes(x = nu, y = Omega)) +
geom_line() +
xlab(expression(nu)) + ylab(expression(Omega)) +
geom_text(label =
"Omega(rho, nu)==frac(pi^frac(nu, 2) ~ rho^nu, Gamma(frac(nu, 2) + 1))",
  parse = TRUE, x = 6, y = 1.5)
```
%
\begin{marginfigure}
\includegraphics[width=\linewidth]{chap3-r_mathnot-1}
\caption{Volume $\Omega$ of the $\nu$-dimensional sphere with radius $\rho=1$, for $\nu=1,\ldots,15$.}
\label{rgraphics:fig:mathnot}
\end{marginfigure}
%
The result is shown in Figure~\ref{rgraphics:fig:mathnot}.
It's also easy to switch to other fonts, for instance the serif font Times
(Figure~\ref{rgraphics:fig:timesfont}).
%
```{r timesfont, fig.width = 3.75, fig.height = 3}
ggplot(genes, aes( x = value, color = gene)) + stat_ecdf() +
  theme(text = element_text(family = "Times"))
```
%
\begin{marginfigure}
\includegraphics[width=\linewidth]{chap3-r_timesfont-1}
\caption{As Figure~\ref{rgraphics:fig:onedecdf}, with a different font.}
\label{rgraphics:fig:timesfont}
\end{marginfigure}
%
In fact, the set of fonts that can be used with a standard R installation are limited, but
luckily there is the package \CRANpkg{extrafont}, which facilitates using fonts other than
R's set of basic PostScript fonts. There's some extra work needed before we can use it,
since fonts external to R first need to be made known to it. They could come shipped with
your operating system, a with word processor or another graphics application. The set of
fonts available and their physical location is therefore not standardized, but will
depend on your operating system and further configurations.  In the first session after
attaching the \CRANpkg{extrafont} package, you will need to run the function
\Rfunction{font\_import} to import fonts and make them known to the package. Then in each
session in which you want to use them, you need to call the \Rfunction{loadfonts} function
to register them with one or more of R's graphics devices. Finally you can use the
\Rfunction{fonttable} function to list the available fonts. You'll need to refer to the
documentation of the \CRANpkg{extrafonts} package to see how to make this work on your
machine.
%
\begin{marginfigure}
\includegraphics[width=\linewidth]{chap3-ecdfs-bauhaus93font} % This file was saved in ../images/
  % from an interactive session on Wolfgang's computer after running the below code chunk named "otherfont".
\caption{As Figure~\ref{rgraphics:fig:onedecdf}, with font ``Bauhaus 93''.}
\label{rgraphics:fig:otherfont}
\end{marginfigure}
%
\begin{ques}
  Use \CRANpkg{extrafont} to produce a version of Figure~\ref{rgraphics:fig:timesfont}
  with the font ``Bauhaus 93'' (or another one available on your system).
\end{ques}
%
```{r otherfont, eval = FALSE, echo = FALSE}
ggplot(genes, aes( x = value, color = gene)) + stat_ecdf() + theme(text = element_text(family = "Bauhaus 93"))
```
%
\begin{ques}
  Have a look at the code producing Figure~\ref{rgraphics:fig:introfig}.
\end{ques}


%-----------------------------------------------------------
\section{Genomic data}
%-----------------------------------------------------------
\begin{marginfigure}
\includegraphics[width=\linewidth]{EBI-genomebrowser-rnaseq}
% source:
% https://www.ebi.ac.uk/training/online/course/ensembl-genomes-non-chordates-quick-tour/what-can-i-do-ensembl-genomes
\caption{Screenshot from Ensembl genome browser, showing gene annotation of a genomic
  region as well as a read pile-up visualization of an RNA-Seq experiment.}
\label{rgraphics:EBI-genomebrowser-rnaseq}
\end{marginfigure}
%
To visualize genomic data, in addition to the general principles we have discussed in this
chapter, there are some specific considerations. The data are usually associated with
genomic coordinates. In fact genomic coordinates offer a great organising principle for
the integration of genomic data. You will probably have seen genome browser displays such
as in Figure~\ref{rgraphics:EBI-genomebrowser-rnaseq}. Here we'll briefly show how to
produce such plots programmatically, using your data as well as public annotation. We can
only give a short glimpse, and we refer to resources such as
\href{https://www.bioconductor.org}{Bioconductor} for a fuller picture.

The main challenge of genomic data visualization is the size of genomes. We need
visualizations at multiple scales, from whole genome down to the nucleotide level. It
should be easy to zoom in and and out, and we may need differemt visualization strategies
for the different size scales. It can be convenient to visualize biological molecules
(genomes, genes, transcripts, proteins) in a linear manner, although their embedding in
the 3D physical world can matter (a lot).

Let's start with some fun examples, an ideogram plot of human chromosome 1
(Figure~\ref{rgraphics:fig:ideogram-1}) and a plot of the genome-wide distribution of RNA
editing sites (Figure~\ref{rgraphics:fig:darned1}).
%
\begin{marginfigure}
\includegraphics[width=\linewidth]{chap3-r_ideo-1}
\caption{Chromosome 1 of the human genome: ideogram plot.}
\label{rgraphics:fig:ideogram-1}
\end{marginfigure}
%
```{r ideo, fig.width=4, fig.height=1.5}
library("ggbio")
data("hg19IdeogramCyto", package = "biovizBase")
plotIdeogram(hg19IdeogramCyto, subchr = "chr1")
```
%
The \Robject{darned\_hg19\_subset500} lists a selection of 500 RNA editing sites in the
human genome. It was obtained from the Database of RNA editing in flies, mice and humans
(DARNED, \url{http://darned.ucc.ie}). The result is shown in
Figure~\ref{rgraphics:fig:darned1}.
%
\begin{marginfigure}
\includegraphics[width=4cm]{chap3-r_darned1-1}
\caption{Karyogram with RNA editing sites. \Robject{exReg} indicates whether a site is in
  the coding region (C), 3'- or 5'-UTR.}
\label{rgraphics:fig:darned1}
\end{marginfigure}
%
```{r darned1, warning = FALSE}
library("GenomicRanges")
data("darned_hg19_subset500", package = "biovizBase")
autoplot(darned_hg19_subset500, layout = "karyogram",
         aes(color = exReg, fill = exReg))
```
\begin{ques}
  Fix the ordering of the chromosome in Figure~\ref{rgraphics:fig:darned1} and get rid of
  the warning about chromosome lengths.
\end{ques}
\begin{answer}
  The information on chromosome lengths in the hg19 assembly of the human genome is (for
  instance) stored in the \Robject{ideoCyto} dataset. In the following, we also use the
  function \Rfunction{keepSeqlevels} to subset and reorder the chromosomes.  See
  Figure~\ref{rgraphics:fig:darned2}
\begin{marginfigure}
\includegraphics[width=4cm]{chap3-r_darned2-1}
\caption{Improved version of Figure~\ref{rgraphics:fig:darned1}.}
\label{rgraphics:fig:darned2}
\end{marginfigure}
%
```{r darned2}
data("ideoCyto", package = "biovizBase")
dn = darned_hg19_subset500
seqlengths(dn) = seqlengths(ideoCyto$hg19)[names(seqlengths(dn))]
dn = keepSeqlevels(dn, paste0("chr", c(1:22, "X")))
autoplot(dn, layout = "karyogram",
         aes(color = exReg, fill = exReg))
```
\end{answer}


What type of object is \Robject{darned\_hg19\_subset500}?
%
```{r whatisdarned1}
darned_hg19_subset500[1:2,]
```
```{r whatisdarned2, echo = FALSE}
stopifnot(is(darned_hg19_subset500, "GRanges"), identical(start(darned_hg19_subset500),end(darned_hg19_subset500)))
```
%
It is a \Rclass{GRanges} object, that is, a specialized class from the Bioconductor
project for storing data that are associated with genomic coordinates. Its first three
columns are obligatory: \Robject{seqnames}, the name of the containing biopolymer (in our
case, these are names of human chromosomes), \Robject{ranges}, the genomic coordinates of
the intervals (in this case, the intervals all have length 1, as they each refer to a
single nucleotide), and the DNA strand from which the RNA is transcribed. You can find out
more on how to use this class and its associated infrastructure in the documentation,
e.\,g., the vignette of the \Biocpkg{GenomicRanges} package.  Learning it is worth the
effort if you want to work with genome-associated datasets, as it allows for convenient,
efficient and safe manipulation of these data and provides many powerful utilities.

To Do
\begin{itemize}
\item Along chromosome plots, annotation + data, with sequence as the integrating principle (Gviz).
\item HilbertViz
\end{itemize}


%------------------------------------------------------------
\section{Recap of this chapter}
%------------------------------------------------------------

\begin{itemize}
\item You should now be comfortable making beautiful, versatile and easily extendable
  plots using \CRANpkg{ggplot2}'s \Rfunction{ggplot}.
\item You should have a basic understanding of the grammar of graphics: the main word
  classes and the basic vocabulary.
\item You understand the importance of choosing the right colors, proportions, and the
  right geom objects.
\item Don't be afraid of setting up your data for faceting -- this is a great
  quick way to look at many different ways to slice the data in different ways.
\item Now you are prepared to explore \CRANpkg{ggplot2} and plot your data on your
  own.
\end{itemize}

%--------------------------------------------------------
\section{Further reading}
%-----------------------------------------------------
The most useful books about \CRANpkg{ggplot2} is the second edition of \citet{ggplot2} and
the \href{http://docs.ggplot2.org/current}{ggplot2} website. There are a lot of
\CRANpkg{ggplot2} code snippets online, which you will find through search engines after
some exercise (stay critical, not everything online is true, or up-to-date). Of course,
the foundation of the system is based on \citet{GrofGrbook} and the ideas by
\citet{Tukey77,Tukey:1988}.


%------------------------------------------------------------
\section{Exercises}
%------------------------------------------------------------
\begin{ex}[Themes]
Explore how to change the visual appearance of plots with themes. For example:
%
```{r theme_bw, fig.width = 3.5, fig.height = 3.5}
ggcars = ggplot(mtcars, aes(x=hp, y=mpg)) + geom_point()
ggcars
ggcars + theme_bw()
ggcars + theme_minimal()
```
\end{ex}

\begin{ex}[Color names in R] Have a look at
\url{http://research.stowers-institute.org/efg/R/Color/Chart}
\end{ex}

\begin{ex}[xkcd]
On a lighter note, you can even modify \CRANpkg{ggplot2} to make plots in
the style of the popular webcomic \href{http://www.xkcd.com}{XKCD}.
You do this through manipulating the font and themes of ggplot2 objects.
See \url{http://stackoverflow.com/questions/12675147/how-can-we-make-xkcd-style-graphs-in-r}.
\begin{marginfigure}
\centering
\includegraphics[width=\linewidth]{xkcdgraph}
\end{marginfigure}
\end{ex}
