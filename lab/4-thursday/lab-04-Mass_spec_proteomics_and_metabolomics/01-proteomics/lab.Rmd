---
title: "Bioconductor tools for mass spectrometry and proteomics"
author: 
- name: Laurent Gatto
  affiliation: Computational Proteomics Unit, Cambridge, UK
output:
  BiocStyle::html_document2:
    toc_float: true
---

```{r env, echo=FALSE, message=FALSE, warning=FALSE}
.cache <- FALSE
suppressPackageStartupMessages(library("BiocStyle"))
suppressPackageStartupMessages(library("MSnbase"))
suppressPackageStartupMessages(library("BiocParallel"))
suppressPackageStartupMessages(library("BiocInstaller"))
suppressPackageStartupMessages(library("RforProteomics"))
suppressPackageStartupMessages(library("lattice"))
suppressPackageStartupMessages(library("gridExtra"))
suppressPackageStartupMessages(library("pRoloc"))
```

**Modified:** `r file.info("lab.Rmd")$mtime`<br />
**Compiled**: `r date()`


**Abstract** In this workflow, we will use R/Bioconductor packages to
explore, process, visualise and understand mass spectrometry-based
proteomics data, starting with raw data, and proceeding with
identification and quantitation data, discussing some of their
peculiarities compared to sequencing data along the way. The workflow
is aimed at a beginner to intermediate level, such as, for example,
seasoned R users who want to get started with mass spectrometry and
proteomics, or proteomics practitioners who want to familiarise
themselves with R and Bioconductor infrastructure.

> This material available under a
> [**creative common CC-BY**](http://creativecommons.org/licenses/by/4.0/)
> license. You are free to **share** (copy and redistribute the
> material in any medium or format) and **adapt** (remix, transform,
> and build upon the material) for any purpose, even commercially.

# Introduction

> **CSAMA 2017** Some part of this workshop require online access. The
> most bandwidth expensive operations are files downloads. Please copy
> the files from the local network and place them in your working
> directory^[If you are not sure what your working directory is, type `getwd()` or ask a helper.]. This
> will stop them from being downloaded again.

Before we start:

> If you identify typos, if there are parts that you would like to see
> expended or clarified, please let me know by telling me directly
> (during workshops), opening a
> [github issue](https://github.com/lgatto/bioc-ms-prot/issues) or by
> emailing me directly. Please do also briefly specify your
> background/familiarity with mass spectrometry and/or proteomics
> (beginner, intermediate or expert) so that I can update accordingly.

In recent years, there we have seen an increase in the number of
packages to analyse mass spectrometry and proteomics data for R and
Bioconductor, as well as an increase in total number of downloads.

![Number of packages](./Figures/development_biocviews.png)
![Number of downloads](./Figures/downloads_biocviews.png)

It is also good to highlight that several of these package have become
a group efforts, supported by several developers in the
community. This [post](https://lgatto.github.io/msnbase-contribs/)
illustrates the various contributions to `r Biocpkg("MSnbase")`; `r
Biocpkg("mzR")` has benefited by a similar wide range of successful
contributions. Both packages, and in particular `r Biocpkg("mzR")`,
are used by many others, and will be described in some detail in this
workflow.

This workflow illustrates R / Bioconductor infrastructure for
proteomics. Topics covered focus on support for open community-driven
formats for raw data and identification results, packages for
peptide-spectrum matching, data processing and analysis:

- Exploring available infrastructure
- Mass spectrometry data
- Getting data from proteomics repositories
- Handling raw MS data
- Handling identification data
- MS/MS database search
- Analysing search results
- High-level data interface
- Quantitative proteomics
- Importing third-party quantitation data
- Data processing and analysis
- Statistical analysis
- Machine learning
- Annotation
- Other relevant packages/pipelines

Links to other packages and references are also documented. In
particular, the vignettes included in the
`r Biocannopkg("RforProteomics")`
package also contains relevant material.

### Other material {-}

This workflow provides a *general* introduction to Bioconductor software
for mass spectrometry and proteomics. If you are interested in 

- Application of machine learning to proteomics data, in particular
  spatial proteomics (i.e. the sub-cellular localisation), follow the
  tutorial vignette from `r Biocpkg("pRoloc")` package, accessible
  with `vignette("pRoloc-tutorial", package = "pRoloc")` or
  [online](https://bioconductor.org/packages/devel/bioc/vignettes/pRoloc/inst/doc/pRoloc-tutorial.html).
- The analysis of identification data to retain the most reliable
  PSMs, see the `r Biocpkg("MSnID")`
  vignette^[Section *Analysing search results* below is a summary of that vignette.],
  accessible with `vignette("msnid_vignette", package = "MSnID")` or
  [online](https://bioconductor.org/packages/release/bioc/vignettes/MSnID/inst/doc/msnid_vignette.pdf). In
  addition, the vignettes of the `r Biocpkg("msmsTest")` package
  describe how to analyse spectral counting data using packages
  dedicated for the analysis of high throughput sequencing data.
- The analysis of MS^E^ data independent acquisition (DIA), see the
  vignettes in the `r Biocpkg("synapter")` package.
- The processing and analysis of MALDI-MS data, read the 
  `r CRANpkg("MALDIquant")` introduction accessible with
  `vignette("MALDIquant-intro", package = "MALDIquant")` and available
  [online](https://cran.r-project.org/web/packages/MALDIquant/).

## Setup { - }

> **CSAMA 2017** This section is not relevant, as you should already
> have installed all required packages.

The follow packages will be used throughout this documents. R version
`3.3.1` or higher is required to install all the packages using
`BiocInstaller::biocLite`.

```{r setup, message=FALSE, echo=TRUE, warning=FALSE}
library("mzR")
library("mzID")
library("MSnID")
library("MSnbase")
library("rpx")
library("MLInterfaces")
library("pRoloc")
library("pRolocdata")
library("MSGFplus")
library("rols")
library("hpar")
```

The most convenient way to install all the tutorials requirement (and
more related content), is to install `r Biocannopkg("RforProteomics")`
with all its dependencies.

```{r r4pinstall, eval=FALSE}
library("BiocInstaller")
biocLite("RforProteomics", dependencies = TRUE)
```

Other packages of interest, such as
`r Biocpkg("rTANDEM")` or `r Biocpkg("MSGFgui")` 
will be described later in the document but are not required to
execute the code in this workflow.


## Exploring available infrastructure { - }

```{r pk, echo=FALSE, warning=FALSE, cache=TRUE}
biocv <- as.character(biocVersion())
pp <- proteomicsPackages(biocv)
msp <- massSpectrometryPackages(biocv)
msdp <- massSpectrometryDataPackages(biocv)
```

In Bioconductor version `r biocv`, there are respectively `r nrow(pp)`
[proteomics](http://bioconductor.org/packages/release/BiocViews.html#___Proteomics),
`r nrow(msp)`
[mass spectrometry software packages](http://bioconductor.org/packages/release/BiocViews.html#___MassSpectrometry)
and `r nrow(msdp)`
[mass spectrometry experiment packages](http://bioconductor.org/packages/release/BiocViews.html#___MassSpectrometryData). These
respective packages can be extracted with the `proteomicsPackages()`,
`massSpectrometryPackages()` and `massSpectrometryDataPackages()` and
explored interactively, or looked at by exploring the respective
`biocViews` on the
[Bioconductor web page](https://bioconductor.org/packages/release/BiocViews.html#___Software).


```{r pp, eval=FALSE}
library("RforProteomics")
pp <- proteomicsPackages()
display(pp)
```

## Mass spectrometry data { - }

Most community-driven formats described in the table are supported in
`R`. We will see how to read and access these data in the following
sections.

```{r datatab, results='asis', echo=FALSE}
datatab <-
    data.frame(Type = c("raw", "identification", "quantitation",
                   "peak lists", "other"),
               Format = c("mzML, mzXML, netCDF, mzData",
                   "mzIdentML", "mzQuantML", "mgf", "mzTab"),
               Package = c(
                   "*[mzR](http://bioconductor.org/packages/mzR)* (read)",
                   paste("*[mzR](http://bioconductor.org/packages/mzR)* (read) and",
                         "*[mzID](http://bioconductor.org/packages/mzID)* (read)"),
                   "",
                   "*[MSnbase](http://bioconductor.org/packages/MSnbase)* (read)", 
                   "*[MSnbase](http://bioconductor.org/packages/MSnbase)* (read)"))
library("knitr")
kable(datatab)
```

# Accessing data

## From the ProteomeXchange database

MS-based proteomics data is disseminated through the
[ProteomeXchange](http://www.proteomexchange.org/) infrastructure,
which centrally coordinates submission, storage and dissemination
through multiple data repositories, such as the
[PRoteomics IDEntifications (PRIDE)](https://www.ebi.ac.uk/pride/archive/)
database at the EBI for mass spectrometry-based experiments (including
quantitative data, as opposed as the name suggests),
[PASSEL](http://www.peptideatlas.org/passel/) at the ISB for Selected
Reaction Monitoring (SRM, i.e. targeted) data and the
[MassIVE](http://massive.ucsd.edu/ProteoSAFe/static/massive.jsp)
resource. These data can be downloaded within R using the 
`r Biocpkg("rpx")` package.


```{r rpx}
library("rpx")
pxannounced()
```

Using the unique `PXD000001` identifier, we can retrieve the relevant
metadata that will be stored in a `PXDataset` object. The names of the
files available in this data can be retrieved with the `pxfiles`
accessor function.

```{r pxd}
px <- PXDataset("PXD000001")
px
pxfiles(px)
```

Other metadata for the `px` data set:

```{r pxvar}
pxtax(px)
pxurl(px)
pxref(px)
```

Data files can then be downloaded with the `pxget` function. Below, we
retrieve the raw data file. The file is
downloaded^[If the file is already available, it is not downloaded a second time.]
in the working directory and the name of the file is return by the
function and stored in the `mzf` variable for later use.

```{r pxget}
fn <- "TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML"
mzf <- pxget(px, fn)
mzf
```


## From AnnotationHub

> **CSAMA 2017** Executing this section will cause raw data file to be
> downloaded and stored as part of the AnnotationHub's local
> resource. The `mzML` file that is available on the local network is
> identical to the one accessed here.

`r Biocpkg("AnnotationHub")` is a cloud resource set up and managed by
the Bioconductor project that serves various omics datasets. It is
possible to contribute and access (albeit currently only a limited
number of)
[proteomics data](http://bioconductor.org/packages/devel/bioc/vignettes/ProteomicsAnnotationHubData/inst/doc/ProteomicsAnnotationHubData.html).

```{r ah0}
library("AnnotationHub")
ah <- AnnotationHub()
query(ah, "proteomics")
```

```{r ah, message=FALSE}
ms <- ah[["AH49008"]]
ms
```

```{r mshd, echo=FALSE}
lms <- length(ms)
hd <- header(ms)
nms1 <- table(hd$msLevel)[[1]]
nms2 <- table(hd$msLevel)[[2]]
```

The data contains `r lms` spectra - `r nms1` MS1 spectra and `r nms2`
MS2 spectra. The file name, `r basename(fileName(ms))`, is not very
descriptive because the data originates from the `AnnotationHub` cloud
repository. If the data was read from a local file, is would be named
as the `mzML` (or `mzXML`) file (see below).


# Handling raw MS data

The `mzR` package provides an interface to the
[proteowizard](http://proteowizard.sourceforge.net/) C/C++ code base
to access various raw data files, such as `mzML`, `mzXML`, `netCDF`,
and `mzData`. The data is accessed on-disk, i.e it is not loaded
entirely in memory, and only when explicitly requested. The three main
functions are `openMSfile` to create a file handle to a raw data file,
`header` to extract metadata about the spectra contained in the file
and `peaks` to extract one or multiple spectra of interest. Other
functions such as `instrumentInfo`, or `runInfo` can be used to gather
general information about a run.

Below, we access the raw data file downloaded in the previous section
and open a file handle that will allow us to extract data and metadata
of interest. 

```{r rawms}
library("mzR")
basename(mzf)
ms <- openMSfile(mzf)
ms
```

The object loaded from *AnnotationHub* in the previous section is of
the same type, and was also created by the `openMSfile` function. All
operations below can equally be applied to it.

The `header` function returns the metadata of all available peaks:

```{r hd}
hd <- header(ms)
dim(hd)
names(hd)
```

We can extract metadata and scan data for scan 1000 as follows:

```{r hdpeaks, fig.cap="Manual extraction and plotting of an MS spectrum"}
hd[1000, ]
head(peaks(ms, 1000))
plot(peaks(ms, 1000), type = "h", xlab = "M/Z", ylab = "Intensity")
```

> **Exercise** Identify the index of the MS2 spectrum with the highest
> precursor intensity (see the `precursorIntensity` feature variable)
> and plot it as illustrated above. 

<details>
```{r answ1}
i <- which.max(hd$precursorIntensity)
sp <- spectra(ms, i)
plot(sp, type = "h", xlab = "M/Z", ylab = "Intensity")
```
</details>

> **Exercise** Are the MS1 and MS2 spectra in profile mode or
> centroided? Choose any spectra and plot the region around a peak to
> find out.

<details>
```{r answ2, fig.width=14, fig.height=7}
par(mfrow = c(1, 2))
bpmz <- hd[i, "basePeakMZ"]
plot(sp, type = "h", xlim = c(bpmz - 0.5, bpmz + 0.5),
     xlab = "M/Z", ylab = "Intensity",
     main = "Centroided")
## Spectrum 100 is MS1
sp1 <- peaks(ms, 100)
plot(sp1, type = "l", xlim = c(536,540),
     xlab = "M/Z", ylab = "Intensity",
     main = "Profile mode")
```
</details>

# Handling identification data

The `RforProteomics` package distributes a small identification result
file that we load and parse using infrastructure from the 
`r Biocpkg("mzR")` package. 

```{r mzrvsid, eval = TRUE}
f <- dir(system.file("extdata", package = "RforProteomics"),
         pattern = "mzid", full.names=TRUE)
basename(f)
```

Along the lines of what is available for raw
data, it provides support fasta parsing `mzIdentML` files with the
`openIDfile` function. As for raw data, the underlying C/C++ code
comes from the [proteowizard](http://proteowizard.sourceforge.net/).

```{r openid}
library("mzR")
id1 <- openIDfile(f)
id1
```

Various data can be extracted from the identification object. The
peptide spectrum matches (PSMs) and the identification scores can be
accessed as a data.frame with `psms` and `score` respectively.

```{r psms}
softwareInfo(id1)
enzymes(id1)
fid1 <- mzR::psms(id1)
head(fid1)
```

```{r iscores}
sc1 <- mzR::score(id1)
head(sc1)
```

The `r Biocpkg("mzID")` package, has similar functionality to parse
identification files, and was the first one to provide such
capabilities in R. The main difference with `r Biocpkg("mzR")` is that
is parses the files using the `r CRANpkg("XML")`package and reads the
whole data into memory rather than relying on proteowizard, and is
slower.

> **Exercise** Data wrangling with identification data; the standard
> `r CRANpkg("tidyverse")` tools are fit for purpose here. Extract and
> combine the PSMs and their scores as described above and combine
> them. From the available data, calculate the length of each peptide
> (you can use `nchar` with the peptide sequence `sequence`) and the
> number of peptides for each protein (`DatabaseDescription`). Plot
> the length of the proteins for their respective number of
> peptides. Optionally, stratify the plot by the peptide e-value score
> (`MS.GF.EValue`) using for example `cut` to define bins.

<details>
```{r answid1, fig.cap="Identifcation data wrangling 1"}
suppressPackageStartupMessages(library("dplyr"))
fid1$peplen <- nchar(as.character(fid1$sequence))
ids <- as_tibble(full_join(fid1, sc1))
npeps <- ids %>% group_by(DatabaseDescription) %>% tally 
ids <- full_join(ids, npeps)
library("ggplot2")
ggplot(ids, aes(x = n, y = DBseqLength)) + geom_point()
```
```{r answid2, fig.cap="Identifcation data wrangling 2"}
ids$evalBins <- cut(ids$MS.GF.EValue, summary(ids$MS.GF.EValue))
ggplot(ids, aes(x = n, y = DBseqLength, color = peplen)) +
    geom_point() +
    facet_wrap(~ evalBins)
```
</details>

# MS/MS database search

While searches are generally performed using third-party software
independently of R or can be started from R using a `system` call, the
`r Biocpkg("MSGFplus")` package enables to perform a search using the
MSGF+ engine, as illustrated below.

We search the `r basename(mzf)` file against the fasta file from
`PXD000001` using `MSGFplus`.

We first download the fasta files from ProteomeXchange

```{r ex_getfas, cache=TRUE}
fas <- pxget(px, "erwinia_carotovora.fasta")
basename(fas)
```

Below, we setup and run the
search^[In the `runMSGF` call, the memory allocated to the java virtual machine is limited to 1GB. In general, there is no need to specify this argument, unless you experience an error regarding the *maximum heap size*.].

```{r ex_msgfplus, message=FALSE, cache=TRUE}
library("MSGFplus")
msgfpar <- msgfPar(database = fas,
                   instrument = 'HighRes',
                   tda = TRUE,
                   enzyme = 'Trypsin',
                   protocol = 'iTRAQ')
idres <- runMSGF(msgfpar, mzf, memory=1000)
idres
## identification file (needed below)
basename(mzID::files(idres)$id)
```

A graphical interface to perform the search the data and explore the
results is also available:

```{r msgfgui, eval=FALSE}
library("MSGFgui")
MSGFgui()
```

![The `r Biocpkg("MSGFgui")` interface](./Figures/MSGFgui.png)

The `r Biocpkg("rTANDEM")` package can be used to perform a search
with *XTandem* software.

# Analysing search results

The `r Biocpkg("MSnID")` package can be used for post-search filtering
of MS/MS identifications. One starts with the construction of an
`MSnID` object that is populated with identification results that can
be imported from a `data.frame` or from `mzIdenML` files. Here, we
will use the example identification data provided with the package.

```{r idf}
mzids <- system.file("extdata", "c_elegans.mzid.gz", package="MSnID")
basename(mzids)
```

We start by loading the package, initialising the `MSnID` object, and
add the identification result from our `mzid` file (there could of
course be more that one).

```{r msnid1}
library("MSnID")
msnid <- MSnID(".")
msnid <- read_mzIDs(msnid, mzids)
show(msnid)
```

Printing the `MSnID` object returns some basic information such as

* Working directory.
* Number of spectrum files used to generate data.
* Number of peptide-to-spectrum matches and corresponding FDR.
* Number of unique peptide sequences and corresponding FDR.
* Number of unique proteins or amino acid sequence accessions and corresponding FDR.


The package then enables to define, optimise and apply filtering based
for example on missed cleavages, identification scores, precursor mass
errors, etc. and assess PSM, peptide and protein FDR levels. To
properly function, it expects to have access to the following data

```{r msnidcols, echo=FALSE}
sort(MSnID:::.mustBeColumns)
```

which are indeed present in our data:

```{r msnidnames}
names(msnid)
```

Here, we summarise a few steps and redirect the reader to the
package's vignette for more details:


## Analysis of peptide sequences

Cleaning irregular cleavages at the termini of the peptides and
missing cleavage site within the peptide sequences. The following two
function call create the new `numMisCleavages` and `numIrrCleabages`
columns in the `MSnID` object

```{r msnidtermini}
msnid <- assess_termini(msnid, validCleavagePattern="[KR]\\.[^P]")
msnid <- assess_missed_cleavages(msnid, missedCleavagePattern="[KR](?=[^P$])")
```

## Trimming the data

Now, we can use the `apply_filter` function to effectively apply
filters. The strings passed to the function represent expressions that
will be evaluated, this keeping only PSMs that have 0 irregular
cleavages and 2 or less missed cleavages.

```{r msnidtrim}
msnid <- apply_filter(msnid, "numIrregCleavages == 0")
msnid <- apply_filter(msnid, "numMissCleavages <= 2")
show(msnid)
```

## Parent ion mass errors

Using `"calculatedMassToCharge"` and `"experimentalMassToCharge"`, the
`mass_measurement_error` function calculates the parent ion mass
measurement error in parts per million.

```{r msnidppm1}
summary(mass_measurement_error(msnid))
```

We then filter any matches that do not fit the +/- 20 ppm tolerance

```{r msnidppm2}
msnid <- apply_filter(msnid, "abs(mass_measurement_error(msnid)) < 20")
summary(mass_measurement_error(msnid))
```

## Filtering criteria

Filtering of the identification data will rely on 

* -log10 transformed MS-GF+ Spectrum E-value, reflecting the goodness
  of match experimental and theoretical fragmentation patterns
  
```{r filt1}
msnid$msmsScore <- -log10(msnid$`MS-GF:SpecEValue`)
```  

* the absolute mass measurement error (in ppm units) of the parent ion

```{r filt2}
msnid$absParentMassErrorPPM <- abs(mass_measurement_error(msnid))
```

MS2 filters are handled by a special `MSnIDFilter` class objects, where
individual filters are set by name (that is present in `names(msnid)`)
and comparison operator (>, <, = , ...)  defining if we should retain
hits with higher or lower given the threshold and finally the
threshold value itself.

```{r filt3}
filtObj <- MSnIDFilter(msnid)
filtObj$absParentMassErrorPPM <- list(comparison="<", threshold=10.0)
filtObj$msmsScore <- list(comparison=">", threshold=10.0)
show(filtObj)
```

We can then evaluate the filter on the identification data object,
which return the false discovery rate and number of retained
identifications for the filtering criteria at hand.

```{r filt4}
evaluate_filter(msnid, filtObj)
```

## Filter optimisation

Rather than setting filtering values by hand, as shown above, these
can be set automativally to meet a specific false discovery rate.

```{r optim1}
filtObj.grid <- optimize_filter(filtObj, msnid, fdr.max=0.01,
                                method="Grid", level="peptide",
                                n.iter=500)
show(filtObj.grid)
```

```{r optim2}
evaluate_filter(msnid, filtObj.grid)
```

Filters can eventually be applied (rather than just evaluated) using
the `apply_filter` function.

```{r optim3}
msnid <- apply_filter(msnid, filtObj.grid)
show(msnid)
```

And finally, identifications that matched decoy and contaminant
protein sequences are removed 

```{r optim4}
msnid <- apply_filter(msnid, "isDecoy == FALSE") 
msnid <- apply_filter(msnid, "!grepl('Contaminant',accession)")
show(msnid)
```

The resulting filtered identification data can be exported to a
`data.frame` or to a dedicated `MSnSet` data structure for
quantitative MS data, described below, and further processed and
analyses using appropriate statistical tests.


# High-level data interface

The above sections introduced low-level interfaces to raw and
identification results. The `r Biocpkg("MSnbase")` package provides
abstractions for raw data through the `MSnExp` class and containers
for quantification data via the `MSnSet` class. Both store

1. the actual assay data (spectra or quantitation matrix, see below),
   accessed with `spectra` (or the `[`, `[[` operators) or `exprs`;
2. sample metadata, accessed as a `data.frame` with `pData`;
3. feature metadata, accessed as a `data.frame` with `fData`.


Another useful slot is `processingData`, accessed with
`processingData(.)`, that records all the processing that objects have
undergone since their creation (see examples below).

The `readMSData2` (there is also a `readMSData` variant - see the `benchmarking` vignette[^Open it with `vignette("benchmarking", package = "MSnbase")` or read it [online](https://bioconductor.org/packages/release/bioc/vignettes/MSnbase/inst/doc/benchmarking.html)]
in `r Biocpkg("MSnbase")` for their differences) will parse the raw
data, extract all MS spectra (by default, but individual MS levels can
selected, as illustrated below) and construct an MS experiment object
of class `MSnExp`.

```{r msnbase}
library("MSnbase")
rawFile <- dir(system.file(package = "MSnbase", dir = "extdata"),
               full.name = TRUE, pattern = "mzXML$")
basename(rawFile)
msexp <- readMSData2(rawFile, msLevel = 2L)
msexp
```

MS2 spectra can be extracted as a list of `Spectrum2` objects with the
`spectra` accessor or as a subset of the original `MSnExp` data with
the `[` operator.  Individual spectra can be accessed with `[[`.

```{r msnb2}
length(msexp)
msexp[1:2]
msexp[[2]]
```

The identification results stemming from the same raw data file can
then be used to add PSM matches.

```{r addid}
fData(msexp)
## find path to a mzIdentML file
identFile <- dir(system.file(package = "MSnbase", dir = "extdata"),
                 full.name = TRUE, pattern = "dummyiTRAQ.mzid")
basename(identFile)
msexp <- addIdentificationData(msexp, identFile)
fvarLabels(msexp)
```

The `readMSData2` (`readMSdata`) and `addIdentificationData` make use
of the `mzR` and `mzID` packages to access the raw and identification
data.

> **Exercise** Are the spectra in the `msexp` object centroided? This
> time, instead of looking at the spectra, we can query (and set) this
> information directly using the `centroided` function (and
> `centroided<-` replacement function). The `isCentroided` function
> can be used to assess the mode from the data.

<details>
```{r answ3}
centroided(msexp)
isCentroided(msexp)
centroided(msexp) <- isCentroided(msexp)
```
</details>

Spectra and (parts of) experiments can be extracted and plotted.

```{r specplot, fig.cap="Plotting a object of class `Spectrum`."}
msexp[[1]]
plot(msexp[[1]], full=TRUE)
```

As this data was labeled with iTRAQ4 isobaric tags, we can highlight
these four peaks of interest with 

```{r specplot1, fig.cap="Plotting a object of class `Spectrum` with reporter ions."}
plot(msexp[[1]], full=TRUE, reporters = iTRAQ4)
```

```{r specplot2, fig.cap="Plotting a object of class `MSnExp`"}
msexp[1:3]
plot(msexp[1:3], full=TRUE)
```

> **Exercise** Repeat the previous combination of raw and
> identification data with the TMT_Erwinia `mzML` and `mzid` files
> that were imported from ProteomeXchange and generated using 
> `r Biocpkg("MSGFplus")` respectively.  Here, we know that the MS1 and
> MS2 level are in profile mode and centroided respectively. Read the
> `readMSData2` documentation to set the `centroided.` argument to set
> these attributes appropriately.

<details>
```{r answ5, cache=TRUE}
tmterw <- readMSData2(mzf, centroided = c(FALSE, TRUE))
table(centroided(tmterw), msLevel(tmterw))
## Let's filter MS2 spectra after reading (optional) and add the
## identification data using pipes
library("magrittr")
tmterw <- tmterw %>%
    filterMsLevel(2L) %>%
    addIdentificationData(idres)
tmterw
```
</details>

# Visualisation

## Visualising raw data

The importance of flexible access to specialised data becomes visible
in the figure
below^[Figure and code taken from the `r Biocannopkg("RforProteomics")` [visualisation vignette](http://bioconductor.org/packages/release/data/experiment/vignettes/RforProteomics/inst/doc/RProtVis.html)]. Not
only can we access specific data and understand/visualise them, but we
can transverse all the data and extracted/visualise/understand
structured slices of data.

![Visual summary of a full round of MS1 and MS2 acquisition for specific MS1 spectrum.](./Figures/visfig-1.png)

In this code chunks we start by selecting relevant spectra of
interest. We will focus on the first MS1 spectrum acquired after 30
minutes of retention time.


```{r pxd1}
## (1) Open raw data file
ms <- openMSfile(mzf)
## (2) Extract the header information
hd <- header(ms)
## (3) MS1 spectra indices
ms1 <- which(hd$msLevel == 1)
## (4) Select MS1 spectra with retention time between 30 and 35 minutes
rtsel <- hd$retentionTime[ms1] / 60 > 30 & hd$retentionTime[ms1] / 60 < 35
## (5) Indices of the 1st and 2nd MS1 spectra after 30 minutes
i <- ms1[which(rtsel)][1]
j <- ms1[which(rtsel)][2]
## (6) Interleaved MS2 spectra
ms2 <- (i+1):(j-1)
```

Now now extract and plot all relevant information:

1. The upper panel represents the chromatogram of the `r fileName(ms)`
   raw data file, produced by plotting the data returned by the
   `chromatogram` function.


```{r visfig01, fig.cap = "A chromatogram."}
plot(chromatogram(ms)[[1]], type = "l")
```

2. We concentrate at a specific retention time, 
   `r formatRt(hd[i, "retentionTime"])` minutes (`r hd[i, "retentionTime"]` seconds) 

```{r visfig02, fig.cap = "A chromatogram with highlighted retention time of interest."}
plot(chromatogram(ms)[[1]], type = "l")
abline(v = hd[i, "retentionTime"]/60, col = "red")
```

3. This corresponds to the `r i`th MS1 spectrum, shown on the second
   row of figures.

```{r visfig03, fig.cap = "The MS1 spectrum at the retention time of interest."}
plot(peaks(ms, i), type = "l", xlim = c(400, 1000))
legend("topright", bty = "n",
       legend = paste0(
           "Acquisition ", hd[i, "acquisitionNum"],  "\n",
           "Retention time ", formatRt(hd[i, "retentionTime"])))
```

4. The ions that were selected for MS2 are highlighted by vertical
   lines. These are represented in the bottom part of the figure.

```{r visfig04, fig.cap = "The MS1 spectrum at the retention time of interest, highlighting the peptides selected for MS2."}
plot(peaks(ms, i), type = "l", xlim = c(400, 1000))
legend("topright", bty = "n",
       legend = paste0(
           "Acquisition ", hd[i, "acquisitionNum"],  "\n",
           "Retention time ", formatRt(hd[i, "retentionTime"])))
abline(v = hd[ms2, "precursorMZ"],
       col = c("#FF000080",
           rep("#12121280", 9)))
```

5. On the right, we zoom on the isotopic envelope of one peptide in
   particular (the one highlighted with a red line).

```{r visfig05, fig.cap = "Isotopic envelope of a peptide."}
plot(peaks(ms, i), type = "l", xlim = c(521, 522.5))
abline(v = hd[ms2, "precursorMZ"], col = "#FF000080")
```

6. A final loop through the relevant MS2 spectra plots the
   `length(ms2)` MS2 spectra highlighted above.

```{r visfig06, fig.width = 8, fig.height = 10, fig.cap = "MS2 spectra of all selected precursors from the previous MS1 spectrum."}
par(mfrow = c(5, 2), mar = c(2, 2, 0, 1))
for (ii in ms2) {
    p <- peaks(ms, ii)
    plot(p, xlab = "", ylab = "", type = "h", cex.axis = .6)
    legend("topright", legend = paste0("Prec M/Z\n",
                           round(hd[ii, "precursorMZ"], 2)),
           bty = "n", cex = .8)
}
```

```{r mslayout, echo=FALSE}
## Preparing the layout (not shown)
lout <- matrix(NA, ncol = 10, nrow = 8)
lout[1:2, ] <- 1
for (ii in 3:4)
    lout[ii, ] <- c(2, 2, 2, 2, 2, 2, 3, 3, 3, 3)
lout[5, ] <- rep(4:8, each = 2)
lout[6, ] <- rep(4:8, each = 2)
lout[7, ] <- rep(9:13, each = 2)
lout[8, ] <- rep(9:13, each = 2)
```

Putting it all together:

```{r visfig, fig.cap = "Visual summary of a full round of MS1 and MS2 acquisition for specific MS1 spectrum."}
layout(lout)
par(mar=c(4,2,1,1))

plot(chromatogram(ms)[[1]], type = "l")
abline(v = hd[i, "retentionTime"]/60, col = "red")
par(mar = c(3, 2, 1, 0))
plot(peaks(ms, i), type = "l", xlim = c(400, 1000))
legend("topright", bty = "n",
       legend = paste0(
           "Acquisition ", hd[i, "acquisitionNum"],  "\n",
           "Retention time ", formatRt(hd[i, "retentionTime"])))
abline(h = 0)
abline(v = hd[ms2, "precursorMZ"],
       col = c("#FF000080",
           rep("#12121280", 9)))

par(mar = c(3, 0.5, 1, 1))
plot(peaks(ms, i), type = "l", xlim = c(521, 522.5),
     yaxt = "n")
abline(h = 0)
abline(v = hd[ms2, "precursorMZ"], col = "#FF000080")

par(mar = c(2, 2, 0, 1))
for (ii in ms2) {
    p <- peaks(ms, ii)
    plot(p, xlab = "", ylab = "", type = "h", cex.axis = .6)
    legend("topright", legend = paste0("Prec M/Z\n",
                           round(hd[ii, "precursorMZ"], 2)),
           bty = "n", cex = .8)
}
```

Below, we illustrate some additional visualisation and animations of
raw MS data, also taken from the `r Biocannopkg("RforProteomics")`
[visualisation vignette](http://bioconductor.org/packages/release/data/experiment/vignettes/RforProteomics/inst/doc/RProtVis.html). On
the left, we have a heatmap visualisation of a MS map and a 3
dimensional representation of the same data. On the right, 2 MS1
spectra in blue and the set of interleaves 10 MS2 spectra.

```{r msmap1, message=FALSE, fig.width=15, echo=TRUE, fig.cap = "Plotting MS maps along retention time, MZ range and intensity."}
## (1) MS space heaptmap
M <- MSmap(ms, ms1[rtsel], 521, 523, .005, hd)
ff <- colorRampPalette(c("yellow", "steelblue"))
trellis.par.set(regions=list(col=ff(100)))
m1 <- plot(M, aspect = 1, allTicks = FALSE)
## (2) Same data as (1), in 3 dimenstion
M@map[msMap(M) == 0] <- NA
m2 <- plot3D(M, rgl = FALSE)
## (3) The 2 MS1 and 10 interleaved MS2 spectra from above
i <- ms1[which(rtsel)][1]
j <- ms1[which(rtsel)][2]
M2 <- MSmap(ms, i:j, 100, 1000, 1, hd)
m3 <- plot3D(M2)
grid.arrange(m1, m2, m3, ncol = 3)
```

Below, we have animations build from extracting successive slices as above.

![MS animation 1](./Figures/msanim1.gif)
![MS animation 2](./Figures/msanim2.gif)

## Visualising identification data

Annotated spectra and comparing spectra. 

```{r id1, message=FALSE, fig.width=15, message=FALSE, fig.cap = "Annotating and comparing MS2 spectra."}
par(mfrow = c(1, 2))
itraqdata2 <- pickPeaks(itraqdata, verbose = FALSE)
s <- "SIGFEGDSIGR"
plot(itraqdata2[[14]], s, main = s)
plot(itraqdata2[[25]], itraqdata2[[28]], sequences = rep("IMIDLDGTENK", 2))
```

The annotation of spectra is obtained by simulating fragmentation of a
peptide and matching observed peaks to fragments:

```{r fag}
calculateFragments("SIGFEGDSIGR")
```

Visualising a pair of spectra means that we can access them, and that,
in addition to plotting, we can manipulate them and perform
computations. The two spectra corresponding to the `IMIDLDGTENK`
peptide, for example have 
`r compareSpectra(itraqdata2[[25]], itraqdata2[[28]], fun = "common")` 
common peaks, a correlation of 
`r round(compareSpectra(itraqdata2[[25]], itraqdata2[[28]], fun = "cor"), 3)` 
and a dot product of 
`r round(compareSpectra(itraqdata2[[25]], itraqdata2[[28]], fun = "dotproduct"), 3)` 
(see `?compareSpectra` for details).


# Quantitative proteomics

There are a wide range of proteomics quantitation techniques that can
broadly be classified as labelled vs. label-free, depending whether
the features are labelled prior the MS acquisition and the MS level at
which quantitation is inferred, namely MS1 or MS2. 

```{r quanttab, echo=FALSE, results='asis'}
qtb <- matrix(c("XIC", "Counting", "SILAC, 15N", "iTRAQ, TMT"),
              nrow = 2, ncol = 2)
dimnames(qtb) <- list(
    'MS level' = c("MS1", "MS2"),
    'Quantitation' = c("Label-free", "Labelled"))

kable(qtb)
```

In terms of raw data quantitation, most efforts have been devoted to
MS2-level quantitation. Label-free XIC quantitation has however been
addressed in the frame of metabolomics data processing by the
`r Biocpkg("xcms")` infrastructure. 

Below is a list of suggested packages for some common proteomics
quantitation technologies:

* Isobaric tagging (iTRAQ and TMT): `r Biocpkg("MSnbase")` and `r Biocpkg("isobar")`.
* Label-free: `r Biocpkg("xcms")` (metabolomics).
* Counting: `r Biocpkg("MSnbase")` and `r Biocpkg("MSnID")` for
  peptide-spectrum matching confidence assessment.
* `r Githubpkg("vladpetyuk/N14N15")` for heavy Nitrogen-labelled data.

### Isobaric tagging {-}

An `MSnExp` is converted to an `MSnSet` by the `quantitation`
method. Below, we use the iTRAQ 4-plex isobaric tagging strategy
(defined by the `iTRAQ4` parameter; other tags are available: see
`?ReporterIons`) and the `max` method to calculate the use the maximum
of the reporter peak for quantitation.

```{r itraq4plot, fig.cap = "MS2 spectrum and it's iTRAQ4 reporter ions."}
plot(msexp[[1]], full=TRUE, reporters = iTRAQ4)
```

```{r quantitraq}
msset <- quantify(msexp, method = "max", reporters = iTRAQ4)
```

The figure below give a schematics of an `MSnSet` instance and the
relation between the assay data and the respective feature and sample
metadata, accessible respectively with the `exprs`, `fData` and
`pData` functions. 

![MSnSet structure](./Figures/msnset.png)

New columns can be added to the metadata slots.

```{r msnsetslots}
exprs(msset)
pData(msset)
pData(msset)$groups <- rep(c("Treat", "Cond"), each = 2)
pData(msset)
```

Another useful slot is `processingData`, accessed with
`processingData(.)`, that records all the processing that objects have
undergone since their creation.


```{r msnsetslots2}
processingData(msset)
```

**See also** The `r Biocpkg("isobar")` package supports quantitation
from centroided `mgf` peak lists or its own tab-separated files that
can be generated from Mascot and Phenyx vendor files.

### Spectral counting {-}

Other MS2 quantitation methods available in `quantify` include the
(normalised) spectral index `SI` and (normalised) spectral abundance
factor `SAF` or simply a simple count
method^[The code below is for illustration only - it doesn't make much sense to perform any of these quantitations on such a multiplexed data].

```{r lfms2}
exprs(si <- quantify(msexp, method = "SIn"))     
exprs(saf <- quantify(msexp, method = "NSAF"))
```

Note that spectra that have not been assigned any peptide (`NA`) or
that match non-unique peptides (`npsm > 1`) are discarded in the
counting process.


As shown above, the `r Biocpkg("MSnID")` package enables to explore
and assess the confidence of identification data using `mzid` files. A
subset of all peptide-spectrum matches, that pass a specific false
discovery rate threshold can them be converted to an `MSnSet`, where
the number of peptide occurrences are used to populate the assay data.

# Importing third-party quantitation data

The Proteomics Standard Initiative (PSI) `mzTab` file format is aimed
at providing a simpler (than XML formats) and more accessible file
format to the wider community. It is composed of a key-value metadata
section and peptide/protein/small molecule tabular sections. These
data can be imported with the `readMzTabData`
function^[We specify version 0.9 (which generates the warning) to fit with the version of that file. For recent files, the `version` argument should be ignored to use the importer for the current file version 1.0.].


```{r mztab, cache=TRUE}
mztf <- pxget(px, "F063721.dat-mztab.txt")
(mzt <- readMzTabData(mztf, what = "PEP", version = "0.9"))
```

It is also possible to import arbitrary spreadsheets as `MSnSet`
objects into R with the `readMSnSet2` function. The main 2 arguments
of the function are (1) a text-based spreadsheet and (2) column names
of indices that identify the quantitation data. The latter can be
queried with the `getEcols` function.

```{r readmsnset2}
csv <- dir(system.file ("extdata" , package = "pRolocdata"),
           full.names = TRUE, pattern = "pr800866n_si_004-rep1.csv")
getEcols(csv, split = ",")
ecols <- 7:10
res <- readMSnSet2(csv, ecols)
head(exprs(res))
head(fData(res))
```

# Data processing and analysis

## Raw data processing

For raw data processing look at `MSnbase`'s `clean`, `smooth`,
`pickPeaks`, `removePeaks` and `trimMz` for `MSnExp` and spectra
processing methods.

As an illustration, we show the `pickPeaks` function on the
`itraqdata` data.

```{r peakpicking, fig.keep = "last", fig.cap = "Peak picking: profile mode."}
library("ggplot2") ## for coord_cartesian
data(itraqdata)
plot(itraqdata[[10]], full = TRUE) +
    coord_cartesian(xlim = c(915, 925))
```

```{r peakpicking2, fig.keep = "last", fig.cap = "Peak picking: centroided."}
itraqdata2 <- pickPeaks(itraqdata)
plot(itraqdata2[[10]], full = TRUE, w1 = 0.05) +
    coord_cartesian(xlim = c(915, 925))
```

The `r Biocpkg("MALDIquant")` and `r Biocpkg("xcms")` packages also
features a wide range of raw data processing methods on their own ad
hoc data instance types.

## Processing and normalisation

Each different types of quantitative data will require their own
pre-processing and normalisation steps. Both `isobar` and `MSnbase`
allow to correct for isobaric tag impurities normalise the
quantitative data.

```{r pure}
data(itraqdata)
qnt <- quantify(itraqdata, method = "trap", reporters = iTRAQ4)
impurities <- matrix(c(0.929, 0.059, 0.002, 0.000,
                       0.020, 0.923, 0.056, 0.001,
                       0.000, 0.030, 0.924, 0.045,
                       0.000, 0.001, 0.040, 0.923),
                     nrow = 4, byrow = TRUE)
## or, using makeImpuritiesMatrix()
## impurities <- makeImpuritiesMatrix(4)
qnt <- purityCorrect(qnt, impurities)
processingData(qnt)
```

Various normalisation methods can be applied the `MSnSet` instances
using the `normalise` method: variance stabilisation (`vsn`), quantile
(`quantiles`), median or mean centring (`center.media` or
`center.mean`), ...

```{r norm}
qnt <- normalise(qnt, "quantiles")
processingData(qnt)
```


The `combineFeatures` method combines spectra/peptides quantitation
values into protein data. The grouping is defined by the `groupBy`
parameter, which is generally taken from the feature metadata (protein
accessions, for example).

```{r comb}
gb <- fData(qnt)$ProteinDescription
prt <- combineFeatures(qnt, groupBy = gb, fun = "median")
processingData(prt)
```

### Missing values {-}

Finally, proteomics data analysis is generally hampered by missing
values. Missing data imputation is a sensitive operation whose success
will be guided by many factors, such as degree and (non-)random nature
of the missingness. 

Below, we load an `MSnSet` with missing values, count the number
missing and non-missing values.

```{r impute0}
data(naset)
table(is.na(naset))
```

The `naplot` figure will reorder cells within the data matrix so that
the experiments and features with many missing values will be grouped
towards the top and right of the heatmap, and barplots at the top and
right summarise the number of missing values in the respective samples
(column) and rows (rows).

```{r naplot, fig.cap = "Overview of missing values."}
naplot(naset)
```

The importance of missing values in a dataset will depend on the
quantitation technology employed. Label-free quantitation in
particular can suffer from a very high number of missing values.

Missing value in `MSnSet` instances can be filtered out with the
`filterNA` functions. By default, it removes features that contain at
least `NA` value.

```{r filterNA}
## remove features with missing values
tmp <- filterNA(naset)
processingData(tmp)
```


It is of course possible to impute missing values (`?impute`). This is
however not a straightforward thing, as is likely to dramatically fail
when a high proportion of data is missing (10s of
%)^[Note that when using `r Biocpkg("limma")` for instance, downstream analyses can handle missing values. Still, it is recommended to explore missingness as part of the exploratory data analysis.]. But
also, there are two types of mechanisms resulting in missing values in
LC/MSMS experiments.

* Missing values resulting from absence of detection of a feature,
  despite ions being present at detectable concentrations.  For
  example in the case of ion suppression or as a result from the
  stochastic, data-dependent nature of the MS acquisition
  method. These missing value are expected to be randomly distributed
  in the data and are defined as **missing at random** (MAR) or
  **missing completely at random** (MCAR).

* Biologically relevant missing values, resulting from the *absence*
  or the low abundance of ions (below the limit of detection of the
  instrument). These missing values are not expected to be randomly
  distributed in the data and are defined as **missing not at random**
  (MNAR).

```{r naheatmap, echo=FALSE, fig.cap="Random and non-random missing values."}
x <- impute(naset, "zero")
exprs(x)[exprs(x) != 0] <- 1
gplots::heatmap.2(exprs(x), col = c("lightgray", "black"),
                  scale = "none", dendrogram = "none",
                  trace = "none", keysize = 0.5, key = FALSE,
                  RowSideColors = ifelse(fData(x)$randna, "orange", "brown"),
                  ColSideColors = rep(c("steelblue", "darkolivegreen"), each = 8))
```

Different imputation methods are more appropriate to different classes
of missing values (as documented in this
[paper](http://pubs.acs.org/doi/abs/10.1021/acs.jproteome.5b00981)). Values
missing at random, and those missing not at random should be imputed
with different methods.

![Root-mean-square error (RMSE) observations standard deviation ratio (RSR), KNN and MinDet imputation. Lower (blue) is better. (See [here](http://pubs.acs.org/doi/abs/10.1021/acs.jproteome.5b00981) for details)](./Figures/imp-sim.png)

Generally, it is recommended to use **hot deck** methods (nearest
neighbour (**left**), maximum likelihood, ...) when data are missing
at random.Conversely, MNAR features should ideally be imputed with a
**left-censor** (minimum value (**right**), but not zero, ...) method.


```{r impute}
## impute missing values using knn imputation
tmp <- impute(naset, method = "knn")
processingData(tmp)
```

There are various methods to perform data imputation, as described in
`?impute`.

# Statistical analysis

R in general and Bioconductor in particular are well suited for the
statistical analysis of data of quantitative proteomics data. Several
packages provide dedicated resources for proteomics data:

- `r Biocpkg("MSstats")`: A set of tools for statistical relative
  protein significance analysis in Data dependent (DDA), SRM and Data
  independent acquisition (DIA) experiments. Data stored in
  `data.frame` or `MSnSet` objects can be used as input.

- `r Biocpkg("msmsTests")`: Statistical tests for label-free LC-MS/MS
  data by spectral counts, to discover differentially expressed
  proteins between two biological conditions. Three tests are
  available: Poisson GLM regression, quasi-likelihood GLM regression,
  and the negative binomial of the `r Biocpkg("edgeR")`
  package. All can be readily applied on `MSnSet` instances produced,
  for example by `MSnID`.

- `r Biocpkg("isobar")` also provides dedicated infrastructure for the
  statistical analysis of isobaric data.

# Machine learning

The `r Biocpkg("MLInterfaces")` package provides a unified interface
to a wide range of machine learning algorithms. Initially developed
for microarray and `ExpressionSet` instances, the
`r Biocpkg("pRoloc")` package enables application of these algorithms
to `MSnSet` data.

## Dimensionality reduction

Dimensionality reduction is very frequently used to summarise
high-dimensional data. Below we will use principal component analysis
(PCA), but other methods can be applied. Below, we will use the
`plot2D` function from the `r Biocpkg("pRoloc")`
package^[While originally developed for the analysis of spatial/organelle proteomics data in mind, it is applicable many use cases.],
that will extract the expression values in the assay data, perform
dimensionality reduction, an produce the scatter plot.

Let's first use `plot2D` to visualise the pattern in 20 protein
quantitation values (initial 20 dimensional data). Here, we use an
example from spatial proteomics, where the quantitative protein
profiles reflect the proteins sub-cellular localisation (from
[Christoforou *et al*, 2016](https://www.nature.com/articles/ncomms9992),
see also
[Breckels *et al*, 2016](https://f1000research.com/articles/5-2926/)
for more data analysis background). We will use the known localisation
of some proteins (marker proteins) to annotate the plot (using the
`fcol` argument).

```{r plot2D1, fig.cap="PCA plot for protein sub-cellular localisation."}
library("pRoloc")
library("pRolocdata")
data(hyperLOPIT2015)
plot2D(hyperLOPIT2015, fcol = "markers")
addLegend(hyperLOPIT2015, fcol = "markers", cex = .7)
```

In other cases, we want to visualise the relation of samples. `plot2D`
uses the rows of the data to perform dimensionality reduction. To use
the columns, we just need to transpose the `MSnSet`. By doing so, the
`pData` becomes the `fData` and vice versa.

Let's use a time-course experiment on stem cells
([Mulvey *et al.* 2015](https://www.ncbi.nlm.nih.gov/pubmed/26059426)). Below,
we use the `times` (time points) variable to set colours and `rep`
(replicate numbers) to set the plotting characters.

```{r plot2S2, fig.cap="PCA plots for sample in a time-course experiment."}
data(mulvey2015)
head(pData(mulvey2015))
plot2D(t(mulvey2015),  fcol = "times", fpch = "rep", cex = 2)
addLegend(t(mulvey2015),  fcol = "times")
```
## Classification

The example below uses `knn` with the 5 closest neighbours and the 
`r Biocpkg("MLInterfaces")` package as an illustration to classify
proteins of unknown sub-cellular localisation to one of 9 possible
organelles.

```{r ml}
library("MLInterfaces")
library("pRolocdata")
data(dunkley2006)
traininds <- which(fData(dunkley2006)$markers != "unknown")
ans <- MLearn(markers ~ ., data = t(dunkley2006), knnI(k = 5), traininds)
ans
```

## Clustering

A wide range of classification and clustering algorithms are also
available, as described in the `?MLearn` documentation page, used
below. 

```{r clust, fig.cap = "Kmeans clustering using `r Biocpkg('MLInterfaces')` with an `MSnSet` object."}
kcl <- MLearn( ~ ., data = dunkley2006, kmeansI, centers = 12)
kcl
plot(kcl, exprs(dunkley2006))
```


# Annotation

```{r nont, echo=FALSE, cache=TRUE}
library("rols")
onts <- Ontologies()
nont <- length(onts)
```

All the
[Bioconductor annotation infrastructure](http://bioconductor.org/help/workflows/annotation/Annotation_Resources/),
such as `r Biocpkg("biomaRt")`, `r Biocannopkg("GO.db")`, 
organism specific annotations, .. are directly relevant to the
analysis of proteomics data. A total of `r nont` ontologies, including
some proteomics-centred annotations such as the PSI Mass Spectrometry
Ontology, Molecular Interaction (PSI MI 2.5) or Protein Modifications
are available through the `r Biocpkg("rols")`


```{r rols}
library("rols")
res <- OlsSearch(q = "ESI", ontology = "MS", exact = TRUE)
res
```

There is a single exact match (default is to retrieve 20 results),
that can be retrieved and coerced to a `Terms` or `data.frame` object
with

```{r rols2}
res <- olsSearch(res)
as(res, "Terms")
as(res, "data.frame")
```

Data from the [Human Protein Atlas](http://www.proteinatlas.org/) is
available via the `r Biocpkg("hpar")` package.

# More information

## References and resources

* [Visualisation of proteomics data using R and Bioconductor](http://www.ncbi.nlm.nih.gov/pmc/articles/PMC4510819/)
* [Using R and Bioconductor for proteomics data analysis](http://arxiv.org/pdf/1305.6559v1.pdf)
* `RforProteomics`: http://bioconductor.org/packages/RforProteomics

## Other relevant packages/pipelines

- Analysis of post translational modification with `r Biocpkg("isobar")`.
- Processing and analysis or isobaric tagging mass spectrometry with
  `r Biocpkg("isobar")` and `r Biocpkg("MSnbase")`.
- Analysis of spatial proteomics data and, more generally, supervised,
  semi-supervised learning, and
  [transfer learning](https://www.ncbi.nlm.nih.gov/pubmed/23523639)
  using the `r Biocpkg("pRoloc")` package.
- Analysis of MALDI data with the `r Biocpkg("MALDIquant")` package.
- Access to the Proteomics Standard Initiative Common QUery InterfaCe
  with the `r Biocpkg("PSICQUIC")` package.
- `r Biocpkg("Cardinal")`: A mass spectrometry imaging toolbox for
  statistical analysis.
- `r Biocpkg("MSnID")`: Utilities for Exploration and Assessment of
  Confidence of LC-MSn Proteomics Identifications.
- `r CRANpkg("protViz") `: Visualising and Analysing Mass Spectrometry
  Related Data in Proteomics
- `r CRANpkg("aLFQ")`: Estimating Absolute Protein Quantities from
  Label-Free LC-MS/MS Proteomics Data.
- `r CRANpkg("protiq")`: Protein (identification and) quantification
  based on peptide evidence.  
- `r Biocpkg("MSstats")`: Protein Significance Analysis in DDA, SRM
  and DIA for Label-free or Label-based Proteomics Experiments


### Data Independent Acquisition

- Analysis of label-free data from a Synapt G2 (including ion
  mobility) with `r Biocpkg("synapter")`.
- `r Biocpkg("SWATH2stats")`: Transform and Filter SWATH Data for
  Statistical Packages and
- `r Biocpkg("specL")`: Prepare Peptide Spectrum Matches for Use in
  Targeted Proteomics
- `r Biocpkg("SwathXtend")`: SWATH extended library generation and
  statistical data analysis

# Session Information

```{r maxprint, echo=FALSE}
options("max.print" = 1e3)
```

```{r si}
sessionInfo()
```
